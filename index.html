<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Client Industry Dashboard</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0/osmtogeojson.min.js"></script>

<!-- LOGIN SCRIPT START -->
<script>
  let isAuthenticated = false;
  const password = "masternino"; // change to your password
  if (!sessionStorage.getItem("loggedIn")) {
    const userPass = prompt("Enter password:");
    if (userPass === password) {
      sessionStorage.setItem("loggedIn", "true");
      isAuthenticated = true;
    } else {
      isAuthenticated = false;
    }
  } else {
    isAuthenticated = true;
  }
</script>
<!-- LOGIN SCRIPT END -->
<style>
body { margin:0; font-family: Arial, sans-serif; height:100vh; overflow: hidden; }
#container { display:grid; grid-template-columns:360px 1fr; height:100vh; }
#accessDenied { display: none; text-align: center; padding: 50px; font-size: 24px; color: #c0392b; }
#accessDenied.show { display: block; }
#sidebar { background:#f5f5f5; padding:15px; overflow-y:auto; border-right:1px solid #ccc; display:flex; flex-direction:column; }
#sidebar input, #sidebar select, #sidebar button { width:100%; padding:8px; margin-bottom:10px; box-sizing:border-box; }
#sidebar select[multiple] { height:250px; min-height:150px; overflow-y:auto; display:none; }
#legendBox { margin:10px 0; padding:10px; background:white; border:1px solid #ccc; border-radius:5px; font-size:13px; display:flex; flex-direction:column; }
.legend-item { display:flex; align-items:center; margin-bottom:6px; cursor:pointer; }
.legend-color { width:14px; height:14px; margin-right:8px; border:1px solid #000; }
#resetLegend { margin-bottom:10px; padding:5px; background:#e74c3c; color:white; border:none; border-radius:3px; cursor:pointer; }
#resetLegend:hover { background:#c0392b; }
#map { width:100%; height:100%; position: relative; }
/* Enhanced weather layer styling - DRAMATIC dark colors for visibility */
.weather-layer-enhanced {
  filter: contrast(2.8) saturate(3.5) brightness(0.6) hue-rotate(10deg) !important;
}
/* Make clouds layer very dark/black */
.weather-layer-clouds {
  filter: brightness(0.15) contrast(3.0) invert(0.2) !important;
}
/* API counter at bottom of map - REMOVED */
.leaflet-bottom.leaflet-left {
  margin-bottom: 10px !important;
}
#chartContainer { width:100%; height:450px; margin-bottom:10px; }
#industryChart { width:100%; height:100%; }
.temp-label {
  background: rgba(0, 0, 0, 0.7) !important;
  border: none !important;
  border-radius: 4px !important;
  padding: 4px 8px !important;
  color: white !important;
  font-weight: bold !important;
  font-size: 13px !important;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
}
.temp-label::before {
  display: none !important;
}
#weatherLayerControls {
  margin: 10px 0;
  padding: 10px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 5px;
  font-size: 13px;
  width: 100%;
  box-sizing: border-box;
}
#weatherLayerControls h4 {
  margin: 0 0 10px 0;
  font-size: 14px;
  color: #333;
}
.weather-toggle {
  display: grid;
  grid-template-columns: 20px 1fr;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
  cursor: pointer;
  padding: 4px;
  border-radius: 3px;
  transition: background 0.2s;
}
.weather-toggle:hover {
  background: #f0f0f0;
}
.weather-toggle input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
  width: 16px;
  height: 16px;
}
.weather-toggle label {
  cursor: pointer;
  margin: 0;
  user-select: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>
</head>
<body>
<div id="container">
  <div id="sidebar">
    <h2>Client Dashboard</h2>
    <div id="clientsNotification" style="display:none; padding:12px; background:#2ecc71; color:white; border-radius:5px; margin-bottom:10px; text-align:center; font-weight:bold; box-shadow:0 2px 8px rgba(0,0,0,0.2);">
      ‚úì <span id="clientCountText">0</span> clients loaded
    </div>
    <div id="loadingStatus" style="padding:10px; background:#fff3cd; border-radius:5px; margin-bottom:10px; display:none; color:#856404;">
      ‚è≥ Loading data...
    </div>
    <div id="controlButtons" style="display:flex; gap:5px; margin-bottom:15px;">
      <button id="addClientBtn" style="flex:1; padding:8px; background:#27ae60; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">+ Add</button>
      <button id="editClientBtn" style="flex:1; padding:8px; background:#3498db; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">‚úé Edit</button>
      <button id="deleteClientBtn" style="flex:1; padding:8px; background:#e74c3c; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">üóë Delete</button>
      <button id="trashBtn" style="flex:1; padding:8px; background:#95a5a6; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">üì¶ Trash</button>
    </div>

    <!-- Add Client Form -->
    <div id="addClientForm" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Add New Client</b>
        <button class="closeForm" data-form="addClientForm" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <input type="text" id="newClientName" placeholder="Client Name" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <input type="text" id="newClientIndustry" placeholder="Industry" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <input type="text" id="newClientLocation" placeholder="Location (e.g., Austin, TX)" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <div style="display:flex; align-items:flex-start; gap:8px; margin-bottom:8px;">
        <textarea id="newClientServiceArea" placeholder="Service Area" rows="3" style="width:260px; padding:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px; height:70px; resize:vertical; font-size:13px;" disabled></textarea>
        <button id="toggleNewAreaEdit" type="button" title="Edit Service Area" style="padding:8px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px; font-size:18px; line-height:1; width:36px; height:36px;">‚úé</button>
      </div>
      <input type="text" id="areaSearchAdd" placeholder="Search ZIP / city / area to preview" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <div style="display:flex; gap:6px; margin-bottom:8px;">
        <button id="previewNewAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;">üîç Preview Area</button>
        <button id="addNewAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;">‚ûï Add to Service Area</button>
      </div>
      <div id="previewNewStatus" style="margin-bottom:8px; font-size:12px; color:#555; display:none;"></div>
      <button id="saveClientBtn" style="width:100%; padding:8px; background:#27ae60; color:white; border:none; border-radius:3px; cursor:pointer;">Save Client</button>
      <div id="geocodeStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <!-- Edit Client Form -->
    <div id="editClientForm" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Edit Client</b>
        <button class="closeForm" data-form="editClientForm" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <select id="clientToEdit" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
        <option value="">Select client to edit...</option>
      </select>
      <input type="text" id="editClientName" placeholder="Client Name" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <input type="text" id="editClientIndustry" placeholder="Industry" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <input type="text" id="editClientLocation" placeholder="Location" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <div style="display:flex; align-items:flex-start; gap:8px; margin-bottom:8px;">
        <textarea id="editClientServiceArea" placeholder="Service Area" rows="3" style="width:260px; padding:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px; height:70px; resize:vertical; font-size:13px;" disabled></textarea>
        <button id="toggleEditAreaEdit" type="button" title="Edit Service Area" style="padding:8px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px; font-size:18px; line-height:1; width:36px; height:36px;" disabled>‚úé</button>
      </div>
      <input type="text" id="areaSearchEdit" placeholder="Search ZIP / city / area to preview" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <div style="display:flex; gap:6px; margin-bottom:8px;">
        <button id="previewEditAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;" disabled>üîç Preview Area</button>
        <button id="addEditAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;" disabled>‚ûï Add to Service Area</button>
      </div>
      <div id="previewEditStatus" style="margin-bottom:8px; font-size:12px; color:#555; display:none;"></div>
      <button id="saveEditBtn" style="width:100%; padding:8px; background:#3498db; color:white; border:none; border-radius:3px; cursor:pointer;" disabled>Save Changes</button>
      <div id="editStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <!-- Delete Client Form -->
    <div id="deleteClientForm" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Delete Client</b>
        <button class="closeForm" data-form="deleteClientForm" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <select id="clientToDelete" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
        <option value="">Select client to delete...</option>
      </select>
      <button id="confirmDeleteBtn" style="width:100%; padding:8px; background:#e74c3c; color:white; border:none; border-radius:3px; cursor:pointer;" disabled>Delete Selected</button>
      <div id="deleteStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <!-- Trash View -->
    <div id="trashView" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Trash</b>
        <button class="closeForm" data-form="trashView" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <div id="trashList" style="max-height:200px; overflow-y:auto; font-size:12px;"></div>
      <div id="trashStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <input type="text" id="searchBox" placeholder="Search client / industry / location..." style="margin-bottom:15px;">
    
    <!-- Weather Layer Controls -->
    <div id="weatherLayerControls">
      <h4>üå¶Ô∏è Weather Layers</h4>
      <div class="weather-toggle">
        <input type="checkbox" id="precipToggle" />
        <label for="precipToggle">Precipitation</label>
      </div>
      <div class="weather-toggle">
        <input type="checkbox" id="cloudsToggle" />
        <label for="cloudsToggle">Cloud Cover</label>
      </div>
      <div class="weather-toggle">
        <input type="checkbox" id="radarToggle" />
        <label for="radarToggle">Radar (Rain)</label>
      </div>
      <div class="weather-toggle">
        <input type="checkbox" id="windToggle" />
        <label for="windToggle">Wind Speed</label>
      </div>
      <div class="weather-toggle">
        <input type="checkbox" id="tempToggle" />
        <label for="tempToggle">Temperature</label>
      </div>
      <div class="weather-toggle">
        <input type="checkbox" id="snowToggle" />
        <label for="snowToggle">Snow</label>
      </div>
    </div>
    <div id="legendBox"></div>
    <button id="toggleChartType">Switch to Pie Chart</button>
    <div id="chartContainer"><canvas id="industryChart"></canvas></div>
  </div>
  <div id="map">
    <!-- API counter removed for fullscreen map -->
  </div>
</div>
<div id="accessDenied">
  <h1 style="margin-top:50px; color:#c0392b;">Access Denied</h1>
  <p>Please reload the page and enter the correct password.</p>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // Check authentication first
  console.log("isAuthenticated:", isAuthenticated);
  if (!isAuthenticated) {
    console.log("Access denied, hiding container");
    document.getElementById("container").style.display = "none";
    document.getElementById("accessDenied").classList.add("show");
    return;
  }
  
  console.log("Authenticated, showing dashboard");
  document.getElementById("accessDenied").style.display = "none";

// MAP INIT
const usaBounds = [[24.396308, -125.0], [49.384358, -66.93457]];
const map = L.map("map", {
  maxBounds: usaBounds,
  maxBoundsViscosity: 1.0,
  minZoom: 4,
  maxZoom: 18
}).setView([37.8, -96], 4);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{ attribution:"&copy; OpenStreetMap" }).addTo(map);
// Create a dedicated pane for service-area layers so markers remain clickable
try {
  map.createPane('serviceAreaPane');
  const p = map.getPane('serviceAreaPane');
  if (p) { p.style.zIndex = 350; }
} catch(_) {}

// WEATHER LAYERS - with bounds set to ensure proper rendering over USA
const usaBoundsLatLng = L.latLngBounds([[24.396308, -125.0], [49.384358, -66.93457]]);
const weatherLayers = {
  precipitation: L.tileLayer('/api/weather?type=tile&layer=precipitation&z={z}&x={x}&y={y}', { 
    opacity: 0.9,
    zIndex: 1000,
    bounds: usaBoundsLatLng,
    className: 'weather-layer-enhanced'
  }),
  clouds: L.tileLayer('/api/weather?type=tile&layer=clouds&z={z}&x={x}&y={y}', { 
    opacity: 0.85,
    zIndex: 1000,
    bounds: usaBoundsLatLng,
    className: 'weather-layer-enhanced weather-layer-clouds'
  }),
  radar: L.tileLayer('/api/weather?type=tile&layer=precipitation&z={z}&x={x}&y={y}', { 
    opacity: 0.95,
    zIndex: 1000,
    bounds: usaBoundsLatLng,
    className: 'weather-layer-enhanced'
  }),
  wind: L.tileLayer('/api/weather?type=tile&layer=wind&z={z}&x={x}&y={y}', { 
    opacity: 0.85,
    zIndex: 1000,
    bounds: usaBoundsLatLng,
    className: 'weather-layer-enhanced'
  }),
  temp: L.tileLayer('/api/weather?type=tile&layer=temp&z={z}&x={x}&y={y}', { 
    opacity: 0.85,
    zIndex: 1000,
    bounds: usaBoundsLatLng,
    className: 'weather-layer-enhanced'
  }),
  snow: L.tileLayer('/api/weather?type=tile&layer=snow&z={z}&x={x}&y={y}', { 
    opacity: 0.9,
    zIndex: 1000,
    bounds: usaBoundsLatLng
  })
};

console.log('[WEATHER] Weather layers created:', weatherLayers);
console.log('[WEATHER] Sample tile URL:', '/api/weather?type=tile&layer=precipitation&z=4&x=3&y=5');

// API Call Counter
let lastLoggedCount = 0;

async function updateApiCallCounter() {
  try {
    // Fetch total from Google Sheet instead of session
    const response = await fetch(APPS_SCRIPT_URL, {
      method: 'POST',
      body: JSON.stringify({
        action: 'getTotalApiCalls'
      })
    });
    
    if (response.ok) {
      const result = await response.json();
      if (result.success && result.data) {
        const total = result.data.total || 0;
        document.getElementById('apiCallCount').textContent = total;
        console.log(`[API STATS] Total OpenWeather API calls: ${total}`);
      }
    }
  } catch (error) {
    console.error('[API STATS] Failed to fetch total:', error);
  }
}

async function logToGoogleSheet(statsData) {
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: 'POST',
      body: JSON.stringify({
        action: 'logApiCall',
        data: {
          apiCalls: statsData.apiCalls,
          sessionStart: statsData.sessionStart
        }
      })
    });
    
    if (response.ok) {
      const result = await response.json();
      if (result.success) {
        console.log('[API STATS] Logged to Google Sheet:', statsData.apiCalls);
      }
    }
  } catch (error) {
    console.error('[API STATS] Failed to log to Google Sheet:', error);
  }
}

// Update counter every 5 seconds
// setInterval(updateApiCallCounter, 5000);
// Log to sheet every 60 seconds
// setInterval(() => {
//   if (lastLoggedCount > 0) {
//     updateApiCallCounter();
//   }
// }, 60000);
// Initial update
// updateApiCallCounter();

// TEST: Add a simple colored overlay to verify layer rendering works
const testOverlay = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { 
  opacity: 0.3,
  zIndex: 999,
  className: 'test-overlay'
});
console.log('[WEATHER] Test overlay created for verification');

// Add tile load event listeners for debugging
Object.keys(weatherLayers).forEach(key => {
  weatherLayers[key].on('tileloadstart', (e) => {
    console.log(`[WEATHER] ${key} tile load started:`, e.coords);
  });
  weatherLayers[key].on('tileload', (e) => {
    console.log(`[WEATHER] ${key} tile loaded successfully:`, e.coords);
  });
  weatherLayers[key].on('tileerror', (e) => {
    console.error(`[WEATHER] ${key} tile load ERROR:`, e.coords, e.error);
  });
});

const precipToggle = document.getElementById("precipToggle");
const cloudsToggle = document.getElementById("cloudsToggle");
const radarToggle = document.getElementById("radarToggle");
const windToggle = document.getElementById("windToggle");
const tempToggle = document.getElementById("tempToggle");
const snowToggle = document.getElementById("snowToggle");

console.log('[WEATHER] Toggle elements found:', {precipToggle, cloudsToggle, radarToggle, windToggle, tempToggle, snowToggle});

if(precipToggle) {
  precipToggle.addEventListener("change", (e) => {
    console.log('[WEATHER] Precipitation toggle:', e.target.checked);
    if(e.target.checked) {
      console.log('[WEATHER] Adding precipitation layer to map...');
      map.addLayer(weatherLayers.precipitation);
      console.log('[WEATHER] Map now has layers:', Object.keys(map._layers).length);
    } else {
      console.log('[WEATHER] Removing precipitation layer from map...');
      map.removeLayer(weatherLayers.precipitation);
    }
  });
}

if(cloudsToggle) {
  cloudsToggle.addEventListener("change", (e) => {
    console.log('[WEATHER] Clouds toggle:', e.target.checked);
    if(e.target.checked) {
      console.log('[WEATHER] Adding clouds layer to map...');
      map.addLayer(weatherLayers.clouds);
      console.log('[WEATHER] Map now has layers:', Object.keys(map._layers).length);
    } else {
      console.log('[WEATHER] Removing clouds layer from map...');
      map.removeLayer(weatherLayers.clouds);
    }
  });
}

if(radarToggle) {
  radarToggle.addEventListener("change", (e) => {
    console.log('[WEATHER] Radar toggle:', e.target.checked);
    if(e.target.checked) {
      console.log('[WEATHER] Adding radar layer to map...');
      map.addLayer(weatherLayers.radar);
      console.log('[WEATHER] Map now has layers:', Object.keys(map._layers).length);
    } else {
      console.log('[WEATHER] Removing radar layer from map...');
      map.removeLayer(weatherLayers.radar);
    }
  });
}

if(windToggle) {
  windToggle.addEventListener("change", (e) => {
    console.log('[WEATHER] Wind toggle:', e.target.checked);
    if(e.target.checked) {
      console.log('[WEATHER] Adding wind layer to map...');
      map.addLayer(weatherLayers.wind);
      console.log('[WEATHER] Map now has layers:', Object.keys(map._layers).length);
    } else {
      console.log('[WEATHER] Removing wind layer from map...');
      map.removeLayer(weatherLayers.wind);
    }
  });
}

if(tempToggle) {
  tempToggle.addEventListener("change", (e) => {
    console.log('[WEATHER] Temperature toggle:', e.target.checked);
    if(e.target.checked) {
      console.log('[WEATHER] Adding temperature layer to map...');
      map.addLayer(weatherLayers.temp);
      console.log('[WEATHER] Map now has layers:', Object.keys(map._layers).length);
    } else {
      console.log('[WEATHER] Removing temperature layer from map...');
      map.removeLayer(weatherLayers.temp);
    }
  });
}

if(snowToggle) {
  snowToggle.addEventListener("change", (e) => {
    console.log('[WEATHER] Snow toggle:', e.target.checked);
    if(e.target.checked) {
      console.log('[WEATHER] Adding snow layer to map...');
      map.addLayer(weatherLayers.snow);
      console.log('[WEATHER] Map now has layers:', Object.keys(map._layers).length);
    } else {
      console.log('[WEATHER] Removing snow layer from map...');
      map.removeLayer(weatherLayers.snow);
    }
  });
}

// COLORS
const colors = {
  "Speciality (Niche)":"#e74c3c","Window Treatments & Coverings":"#3498db","Home Organization & Closets":"#2ecc71",
  "Kitchens":"#f39c12","Pools":"#1abc9c","Roofing":"#9b59b6","Construction":"#34495e",
  "Painters":"#ff6f61","Fencing":"#16a085","Floor Coating":"#8e44ad","Landscaping":"#27ae60",
  "Cleaning":"#00bcd4","Pest Control":"#795548","Flooring":"#607d8b","Events Place":"#d35400",
  "Power Washing":"#00acc1","Home Improvement":"#5e35b1"
};

// GOOGLE SHEET CONFIG
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTLuqA1azB3yyRdwNLBIV5WLcO7CezuoMD4yEOtk-MF7V8RTq2ehxR5JnFOCGDQ4-v10TVtmpnTaSn2/pub?output=csv";
const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxZ9tU23L7hHJJxQ-EP-T8rh2Uxl3_UdA4LFlGUTuEdZoyz1ZMK1rO_Q3oRj2_y_eZ_/exec";

// GEOCODE LOCATION
async function geocodeLocation(location) {
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(location)}&format=json&limit=1`);
    const data = await res.json();
    if(data.length > 0) {
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }
  } catch(e) {}
  return [39.5, -98.35];
}

// PARSE CSV
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cell = "";
  let insideQuotes = false;
  
  for(let i = 0; i < text.length; i++) {
    const char = text[i];
    const nextChar = text[i + 1];
    
    if(char === '"') {
      if(insideQuotes && nextChar === '"') {
        cell += '"';
        i++;
      } else {
        insideQuotes = !insideQuotes;
      }
    } else if(char === ',' && !insideQuotes) {
      row.push(cell.trim());
      cell = "";
    } else if((char === '\n' || char === '\r') && !insideQuotes) {
      if(cell || row.length > 0) {
        row.push(cell.trim());
        if(row.some(c => c)) rows.push(row);
        row = [];
        cell = "";
      }
      if(char === '\r' && nextChar === '\n') i++;
    } else {
      cell += char;
    }
  }
  if(cell || row.length > 0) {
    row.push(cell.trim());
    if(row.some(c => c)) rows.push(row);
  }
  return rows;
}

// FETCH CLIENTS
async function fetchClientsFromSheet() {
  try {
    let csv = null;
    try {
      const res = await fetch(CSV_URL);
      if(res.ok) csv = await res.text();
    } catch(e) {}
    
    if(!csv) return [];
    
    const rows = parseCSV(csv);
    if(rows.length < 2) return [];
    
    const parsed = [];
    for(let i = 1; i < rows.length; i++) {
      const cells = rows[i];
      if(cells.length >= 3 && cells[0]) {
        const name = cells[0].replace(/^"|"$/g, '').trim();
        const industry = (cells[1] || "Unknown").replace(/^"|"$/g, '').trim();
        const location = (cells[2] || "Unknown").replace(/^"|"$/g, '').trim();
        const lat = cells[4] ? parseFloat(cells[4]) : null;
        const lng = cells[5] ? parseFloat(cells[5]) : null;
        
        const serviceArea = (cells[3] || "").replace(/^"|"$/g, '').trim();
        let coords = [39.5, -98.35];
        if(lat && lng && !isNaN(lat) && !isNaN(lng)) {
          coords = [lat, lng];
        } else {
          coords = await geocodeLocation(location);
        }
        parsed.push([name, industry, location, serviceArea, coords]);
      }
    }
    return parsed;
  } catch(e) {
    return [];
  }
}

let clients = [];
let filteredClients = [];
let legendStatus = {};
let markers = [], chart=null, currentChartType="bar";

(async () => {
  clients = await fetchClientsFromSheet();
  
  // Show notification with client count
  const notification = document.getElementById('clientsNotification');
  document.getElementById('clientCountText').textContent = clients.length;
  notification.style.display = 'block';
  
  // Auto-hide after 5 seconds
  setTimeout(() => {
    notification.style.display = 'none';
  }, 5000);
  
  // Localhost-only demo: inject service areas for preview without sheet changes
  if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
    try {
      const demo = "49501, 49503, Grand Rapids, MI";
      clients = clients.map(c => {
        if ((c[0]||"").toLowerCase().includes("north shore brick")) {
          // c = [name, industry, location, serviceArea, coords]
          c[3] = c[3] && c[3].trim().length ? c[3] : demo;
        }
        return c;
      });
    } catch(_) {}
  }
  setupFilters();
  buildLegend();
  loadMarkers(clients);
})();

// FETCH WEATHER
async function fetchWeather(lat, lng) {
  try {
    const res = await fetch(`/api/weather?lat=${lat}&lng=${lng}`);
    if (!res.ok) return { temp:"N/A", tzOffset:0 };
    const d = await res.json();
    return {
      temp: typeof d?.main?.temp === "number" ? d.main.temp.toFixed(1) : "N/A",
      tzOffset: typeof d?.timezone === "number" ? d.timezone : 0
    };
  } catch(e) {
    return { temp:"N/A", tzOffset:0 };
  }
}

// FORMAT LOCAL TIME
function formatLocalTime(offsetSeconds) {
  const utc = new Date().getTime() + new Date().getTimezoneOffset()*60000;
  const local = new Date(utc + offsetSeconds*1000);
  let hours = local.getHours();
  const mins = String(local.getMinutes()).padStart(2,'0');
  const ampm = hours>=12?"PM":"AM";
  const hr12 = hours%12||12;
  return `${hr12}:${mins} ${ampm}`;
}

// SETUP POPUP
async function setupPopup(marker, client) {
  const [name, inds, loc, serviceArea, coords] = client;
  marker.bindPopup(`<b>${name}</b><br>Industry: ${inds}<br>Location: ${loc}<br>Loading‚Ä¶`);
  
  // Add permanent temperature label
  marker.bindTooltip('Loading...', { 
    permanent: true, 
    direction: 'top',
    offset: [0, -10],
    className: 'temp-label'
  });
  
  const update = async () => {
    try {
      const {temp, tzOffset} = await fetchWeather(coords[0], coords[1]);
      const timeStr = formatLocalTime(tzOffset);
      marker.getPopup().setContent(`<b>${name}</b><br>Industry: ${inds}<br>Location: ${loc}<br>Local Time: ${timeStr}<br>Temp: ${temp}¬∞C`);
      marker.setTooltipContent(`${temp}¬∞C`);
    } catch(_) {
      marker.getPopup().setContent(`<b>${name}</b><br>Industry: ${inds}<br>Location: ${loc}<br>Local Time: N/A<br>Temp: N/A`);
      marker.setTooltipContent('N/A');
    }
  };
  await update();
  setInterval(update, 10*60*1000);

  // Show popup on hover; click is reserved for service-area polygons
  marker.on('mouseover', () => {
    try { marker.openPopup(); } catch(_) {}
  });
  marker.on('mouseout', () => {
    try { marker.closePopup(); } catch(_) {}
  });
}

// --- Service Area (ZIP/Location) Polygons ---
const SERVICE_AREA_STYLE = {
  color: '#e74c3c',
  weight: 2,
  fillColor: '#e74c3c',
  fillOpacity: 0.15  // Reduced from 0.25 to be more transparent
};

const OVERLAP_STYLE = {
  color: '#e74c3c',
  weight: 2,
  dashArray: '4 4',
  fillColor: '#e74c3c',
  fillOpacity: 0.15
};

function getServiceAreaCache() {
  try { return JSON.parse(localStorage.getItem('serviceAreaCache')||'{}'); } catch(_) { return {}; }
}
function setServiceAreaCache(cache) {
  try { localStorage.setItem('serviceAreaCache', JSON.stringify(cache)); } catch(_) {}
}

// --- Service area preview helpers ---
let previewLayer = null;
const lastPreviewEntry = { add: null, edit: null };

function clearPreviewLayer() {
  if (previewLayer) {
    try { map.removeLayer(previewLayer); } catch(_) {}
    previewLayer = null;
  }
}

function appendEntryToInput(inputEl, entry, statusEl) {
  const parts = inputEl.value.split(',').map(p => p.trim()).filter(Boolean);
  if (parts.includes(entry)) {
    if (statusEl) setPreviewStatus(statusEl, `"${entry}" already exists in Service Area`);
    return false; // duplicate
  }
  parts.push(entry);
  inputEl.value = parts.join(', ');
  return true; // added successfully
}
function dedupeServiceAreaInput(inputEl) {
  const parts = inputEl.value.split(',').map(p => p.trim()).filter(Boolean);
  inputEl.value = [...new Set(parts)].join(', ');
}

function setPreviewStatus(el, msg) {
  if (!el) return;
  el.style.display = 'block';
  el.textContent = msg;
}

async function previewServiceAreaEntry(entry, statusEl, contextKey) {
  if (!entry) {
    setPreviewStatus(statusEl, 'Enter a ZIP or place');
    return null;
  }
  const attempts = normalizeServiceAreaInput(entry).slice(0, 10); // try up to 10 entries
  if (attempts.length === 0) {
    setPreviewStatus(statusEl, 'Enter a ZIP or place');
    return null;
  }
  setPreviewStatus(statusEl, 'Searching‚Ä¶');
  clearPreviewLayer();
  for (const attempt of attempts) {
    try {
      const result = await fetchPolygonForEntry(attempt);
      if (!result || !result.feature) continue;
      previewLayer = L.geoJSON(result.feature, { style: SERVICE_AREA_STYLE }).addTo(map);
      try {
        // Use click (not once) to allow multiple prompts on same preview
        previewLayer.on('click', () => {
          const ask = confirm(`Add ${result.label || attempt} to Service Area?`);
          if (!ask) return;
          const input = (contextKey === 'edit') ? document.getElementById('editClientServiceArea') : document.getElementById('newClientServiceArea');
          const statusEl = (contextKey === 'edit') ? document.getElementById('previewEditStatus') : document.getElementById('previewNewStatus');
          const added = appendEntryToInput(input, result.label || attempt, statusEl);
          if (added) {
            dedupeServiceAreaInput(input);
            setPreviewStatus(statusEl, `Added ${result.label || attempt} to Service Area`);
            if (contextKey === 'edit') {
              try {
                const idxVal = parseInt(document.getElementById('clientToEdit').value);
                if (!isNaN(idxVal)) {
                  const originalClient = clients[idxVal];
                  fetch(APPS_SCRIPT_URL, {
                    method: 'POST',
                    body: JSON.stringify({
                      action: 'editClient',
                      data: {
                        originalName: originalClient[0],
                        name: document.getElementById('editClientName').value.trim(),
                        industry: document.getElementById('editClientIndustry').value.trim(),
                        location: document.getElementById('editClientLocation').value.trim(),
                        serviceArea: input.value.trim(),
                        lat: originalClient[4][0],
                        lng: originalClient[4][1]
                      }
                    })
                  }).then(r=>r.json()).then(res=>{
                    if (res.success) setPreviewStatus(statusEl, `‚úì Saved to database`);
                  }).catch(()=>{});
                }
              } catch(_) {}
            }
          }
        });
      } catch(_) {}
      try { map.fitBounds(previewLayer.getBounds(), { padding: [20, 20] }); } catch(_) {}
      setPreviewStatus(statusEl, `Previewing: ${result.label || attempt}`);
      lastPreviewEntry[contextKey] = attempt;
      return result;
    } catch(err) {
      console.error('[PREVIEW] Error for', attempt, err);
    }
  }
  setPreviewStatus(statusEl, 'No polygon found');
  return null;
}

function normalizeServiceAreaInput(str) {
  if (!str) return [];
  const lines = str.replace(/\r\n/g,'\n').split(/\n/).map(s=>s.trim()).filter(Boolean);
  const out = [];
  for (const line of lines) {
    // Split by comma first
    const tokens = line.split(',').map(t=>t.trim()).filter(Boolean);
    // Separate ZIPs from city/state
    const zips = tokens.filter(isZip);
    const nonZips = tokens.filter(t=>!isZip(t));
    
    // Add each ZIP separately
    zips.forEach(z => out.push(z));
    
    // Add non-ZIP tokens as separate entries or join them
    if (nonZips.length > 0) {
      out.push(nonZips.join(', '));
    }
  }
  return out;
}

function isZip(s) { return /^\d{5}$/.test(s); }

async function fetchPolygonForEntry(entry) {
  // Returns { feature, label } where feature is a GeoJSON Feature (Polygon/MultiPolygon)
  const cache = getServiceAreaCache();
  if (cache[entry]) {
    const c = cache[entry];
    if (c.type === 'feature') {
      return { feature: c.feature, label: c.label || entry };
    }
  }

  // Fetch from backend (Google Apps Script handles Nominatim lookup)
  const url = `${APPS_SCRIPT_URL}?action=getPolygon&entry=${encodeURIComponent(entry)}`;
  console.log(`[POLY-FETCH] Backend URL for ${entry}: ${url}`);
  
  try {
    await new Promise(r=>setTimeout(r, 100)); // Small delay to avoid overwhelming backend
    const res = await fetch(url);
    const data = await res.json();
    console.log(`[POLY-FETCH] Backend response for ${entry}:`, data);
    
    if (data.feature && data.label) {
      cache[entry] = { type:'feature', feature: data.feature, label: data.label };
      setServiceAreaCache(cache);
      return { feature: data.feature, label: data.label };
    } else if (data.error) {
      console.error(`[POLY-FETCH] Backend error for ${entry}:`, data.error);
    }
  } catch(err) {
    console.error(`[POLY-FETCH] Fetch error for ${entry}:`, err);
  }

  // Overpass fallback: fetch polygon for postal_code
  if (isZip(entry)) {
    try {
      const overpassQuery = `data=[out:json][timeout:10];(relation["boundary"="administrative"]["postal_code"="${entry}"];relation["boundary"="postal_code"]["postal_code"="${entry}"];way["postal_code"="${entry}"];);out body;>;out skel qt;`;
      const overpassUrl = `https://overpass-api.de/api/interpreter?${overpassQuery}`;
      console.log(`[POLY-FETCH] Overpass URL for ${entry}: ${overpassUrl}`);
      await new Promise(r=>setTimeout(r, 250));
      const res = await fetch(overpassUrl, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (data?.elements?.length) {
        // Convert Overpass result to GeoJSON via simple interpretation
        const geo = osmtogeojson(data);
        if (geo?.features?.length) {
          // Take first polygon/multipolygon feature
          const poly = geo.features.find(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
          if (poly) {
            // Try to get a better label from previous Nominatim attempt
            let label = entry;
            if (Array.isArray(data?.elements) && data.elements.length > 0) {
              const tags = data.elements[0].tags;
              if (tags?.name) label = `${tags.name} ${entry}`;
            }
            const feature = { type:'Feature', geometry: poly.geometry, properties:{ label } };
            cache[entry] = { type:'feature', feature, label };
            setServiceAreaCache(cache);
            console.log(`[POLY-FETCH] Using Overpass polygon for ${entry}`);
            return { feature, label };
          }
        }
      }
    } catch(err) {
      console.error(`[POLY-FETCH] Overpass error for ${entry}:`, err);
    }

    // Final fallback: US Census TIGER ZIP boundaries via public API
    try {
      const censusUrl = `https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Current/MapServer/2/query?where=ZCTA5='${entry}'&outFields=*&outSR=4326&f=geojson`;
      console.log(`[POLY-FETCH] Census TIGER URL for ${entry}: ${censusUrl}`);
      await new Promise(r=>setTimeout(r, 500));
      const res = await fetch(censusUrl);
      if (!res.ok) {
        console.error(`[POLY-FETCH] Census TIGER HTTP ${res.status} for ${entry}`);
        return null;
      }
      const data = await res.json();
      console.log(`[POLY-FETCH] Census TIGER response:`, data);
      if (data?.features?.length) {
        const poly = data.features[0];
        if (poly.geometry && (poly.geometry.type === 'Polygon' || poly.geometry.type === 'MultiPolygon')) {
          const label = entry; // ZIP only for Census data
          const feature = { type:'Feature', geometry: poly.geometry, properties:{ label } };
          cache[entry] = { type:'feature', feature, label };
          setServiceAreaCache(cache);
          console.log(`[POLY-FETCH] Using Census TIGER polygon for ${entry}`);
          return { feature, label };
        }
      }
    } catch(err) {
      console.error(`[POLY-FETCH] Census TIGER error for ${entry}:`, err);
    }
  }
  // No polygon geojson available; skip to avoid boxy fallbacks
  return null;
}

function buildLabel(entry, item) {
  // Format: "City ST ZIP" or just "ZIP" if no city found
  try {
    if (isZip(entry)) {
      const disp = (item?.display_name||'').split(',').map(s=>s.trim());
      // Filter out the ZIP itself from display_name parts
      const parts = disp.filter(p => p !== entry && !/^\d{5}$/.test(p));
      const city = parts[0] || '';
      const state = parts.find(v=>/\b[A-Z]{2}\b/.test(v)) || '';
      // Build clean label without duplicating ZIP
      if (city && state) {
        return `${city} ${state} ${entry}`;
      } else if (city) {
        return `${city} ${entry}`;
      } else {
        return entry; // Just ZIP if no city found
      }
    } else {
      return entry; // keep user-provided for locations
    }
  } catch(_) { return entry; }
}

async function setupServiceAreaOnClick(marker, client) {
  const [name, inds, loc, serviceArea /*string*/, coords] = client;
  console.log(`[SA] Setting up for ${name}, serviceArea: "${serviceArea}"`);
  const entries = [...new Set(normalizeServiceAreaInput(serviceArea))].slice(0, 12);
  console.log(`[SA] Normalized entries:`, entries);
  if (entries.length === 0) {
    console.log(`[SA] No entries, returning`);
    return;
  }
  if (!window.__serviceAreaLayers) window.__serviceAreaLayers = {};

  // Attach click handler (fresh each time)
  marker.on('click', async () => {
    console.log(`[SA] Click handler fired for ${name}`);
    const existing = window.__serviceAreaLayers[name];
    if (existing) {
      try { existing.clearLayers(); } catch(_) {}
      try { map.removeLayer(existing); } catch(_) {}
      delete window.__serviceAreaLayers[name];
      console.log(`[SA-TOGGLE] Removed service area for ${name}`);
      return; // Exit early after toggle off
    }

    // Show areas
    const group = L.featureGroup().addTo(map);
    const features = [];
    const labels = [];
    for (const e of entries) {
      console.log(`[SA-FETCH] Fetching polygon for: ${e}`);
      const result = await fetchPolygonForEntry(e);
      console.log(`[SA-FETCH] Got result:`, result);
      if (!result) { console.log(`[SA-FETCH] No result for ${e}`); continue; }
      features.push(result.feature);
      labels.push(result.label);
    }
    console.log(`[SA-RENDER] Got ${features.length}/${entries.length} features`);
    if (features.length === 0) { window.__serviceAreaLayers[name] = group; return; }

    // Compute union for solid combined polygon
    let unionFeat = features[0];
    if (typeof turf !== 'undefined') {
      try {
        for (let i=1;i<features.length;i++) {
          const u = turf.union(unionFeat, features[i]);
          if (u) unionFeat = u;
        }
      } catch(err) { console.error('[SA-UNION] Error:', err); }
    }
    try {
      L.geoJSON(unionFeat, { style: SERVICE_AREA_STYLE, interactive:false, pane:'serviceAreaPane' }).addTo(group);
      console.log('[SA-RENDER] Union polygon added to map');
    } catch(err) { console.error('[SA-RENDER] Error adding union:', err); }

        // Add a blue pin icon with shadow at each entry center
        const pinIcon = L.icon({
          iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIzNiIgdmlld0JveD0iMCAwIDI0IDM2Ij48ZGVmcz48ZmlsdGVyIGlkPSJzaGFkb3ciPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHN0ZERldmlhdGlvbj0iMiIvPjxmZU9mZnNldCBkeD0iMCIgZHk9IjIiIHJlc3VsdD0ib2Zmc2V0Ymx1ciIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSIjMDAwIiBmbG9vZC1vcGFjaXR5PSIwLjMiLz48ZmVDb21wb3NpdGUgaW4yPSJvZmZzZXRibHVyIiBvcGVyYXRvcj0iaW4iLz48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj0iU291cmNlR3JhcGhpYyIvPjwvZmVNZXJnZT48L2ZpbHRlcj48L2RlZnM+PGcgZmlsdGVyPSJ1cmwoI3NoYWRvdykiPjxwYXRoIGZpbGw9IiM0MDk2Q0UiIGQ9Ik0xMiAwQzUuNCAwIDAgNS40IDAgMTJjMCA4IDggMTYgMTIgMjQgNC04IDEyLTE2IDEyLTI0IDAtNi42LTUuNC0xMi0xMi0xMnptMCAxNmMtMi4yIDAtNC0xLjgtNC00czEuOC00IDQtNCA0IDEuOCA0IDQtMS44IDQtNCA0eiIvPjwvZz48L3N2Zz4=',
          iconSize: [24, 36],
          iconAnchor: [12, 36],
          popupAnchor: [0, -36]
        });
        for (let i=0;i<features.length;i++) {
          const feat = features[i];
          let lat = null, lon = null;
          try {
            if (typeof turf !== 'undefined' && turf.center) {
              const center = turf.center(feat);
              if (center?.geometry?.coordinates) {
                [lon, lat] = center.geometry.coordinates;
              }
            }
          } catch(_) {}
          if (!lat || !lon) {
            try {
              const bbox = turf.bbox ? turf.bbox(feat) : null;
              if (bbox) { lon = (bbox[0]+bbox[2])/2; lat = (bbox[1]+bbox[3])/2; }
            } catch(_) {}
          }
          if (lat && lon) {
            L.marker([lat, lon], { icon: pinIcon, interactive:false }).addTo(group).bindTooltip(labels[i], { permanent:false, direction:'top' });
          }
        }

    // Add invisible hover layers for per-entry tooltips
    try {
      features.forEach((f, idx) => {
        L.geoJSON(f, { style: { color:'#0000', weight:0, fillOpacity:0, interactive:true }, pane:'serviceAreaPane' })
          .addTo(group)
          .bindTooltip(labels[idx], { permanent:false, direction:'center' });
      });
    } catch(err) { console.error('[SA-TOOLTIPS] Error:', err); }

    // Draw dashed overlays for overlaps
    if (typeof turf !== 'undefined') {
      for (let i=0;i<features.length;i++) {
        for (let j=i+1;j<features.length;j++) {
          try {
            const inter = turf.intersect(features[i], features[j]);
            if (inter) L.geoJSON(inter, { style: OVERLAP_STYLE, pane:'serviceAreaPane' }).addTo(group);
          } catch(_) {}
        }
      }
    }

    window.__serviceAreaLayers[name] = group;
    console.log('[SA-COMPLETE] Service area rendered and cached for', name);
    try { 
      if (group.getLayers && group.getLayers().length > 0) {
        map.fitBounds(group.getBounds(), { padding: [50, 50] }); 
      }
    } catch(e) { console.error('[SA-FITBOUNDS]', e); }
  });
}

// LOAD MARKERS
function loadMarkers(data) {
  console.log(`[LOAD] loadMarkers called with ${data.length} clients`);
  markers.forEach(m=>map.removeLayer(m));
  markers=[];
  filteredClients = data;
  // Clear any previously rendered service area layers
  if (window.__serviceAreaLayers) {
    Object.values(window.__serviceAreaLayers).forEach(lg => { try { lg.remove(); } catch(_){} });
    window.__serviceAreaLayers = {};
  }
  data.forEach(item=>{
    const [name, inds, loc, serviceArea, coords] = item;
    console.log(`[LOAD] Marker: ${name}, serviceArea="${serviceArea}", coords=${JSON.stringify(coords)}`);
    const mk = L.circleMarker(coords,{ radius:8, fillColor: colors[inds.split(",")[0].trim()]||"#666", color:"#000", weight:1, fillOpacity:0.9 }).addTo(map);
    mk.industries = inds.split(",").map(i=>i.trim());
    if(mk.industries.some(i=>legendStatus[i])) map.removeLayer(mk);
    setupPopup(mk, item);
    setupServiceAreaOnClick(mk, item);
    markers.push(mk);
  });
  updateChart(data);
}

// UPDATE CHART
function updateChart(data){
  const counts={}, colorArr={};
  data.forEach(c=>{
    c[1].split(",").map(i=>i.trim()).forEach(i=>{ counts[i]=(counts[i]||0)+1; colorArr[i]=colors[i]||"#666"; });
  });
  let labels=Object.keys(counts).sort();
  const values=labels.map(l=>counts[l]);
  const bg=labels.map(l=>colorArr[l]);
  if(chart) chart.destroy();
  chart=new Chart(document.getElementById("industryChart"),{
    type: currentChartType,
    data:{ labels, datasets:[{ data:values, backgroundColor:bg, borderWidth:0 }] },
    options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false }}, scales: currentChartType==="bar"?{y:{beginAtZero:true},x:{display:false}}:{} }
  });
}

// FILTERS
function applyFilters(){
  const s=document.getElementById("searchBox").value.toLowerCase().trim();
  const filtered = clients.filter(c=>{
    const txt=(c[0]+" "+c[1]+" "+c[2]).toLowerCase();
    if(s && !txt.includes(s)) return false; // Search filter
    const industries = c[1].split(",").map(i=>i.trim());
    return !industries.some(ind=>legendStatus[ind]); // Exclude if any industry is hidden
  });
  loadMarkers(filtered);
}

function setupFilters(){}

// GEOCODE & VALIDATE
async function geocodeAndValidate(location) {
  const statusDiv = document.getElementById("geocodeStatus");
  statusDiv.innerHTML = "üîç Geocoding...";
  statusDiv.style.display = "block";
  

  // Preview/add service area on Add Client form
  const previewNewBtn = document.getElementById("previewNewAreaBtn");
  const addNewBtn = document.getElementById("addNewAreaBtn");
  if (previewNewBtn && addNewBtn) {
    previewNewBtn.addEventListener("click", async () => {
      const src = document.getElementById("areaSearchAdd").value.trim();
      const entry = src || document.getElementById("newClientServiceArea").value.trim();
      await previewServiceAreaEntry(entry, document.getElementById("previewNewStatus"), 'add');
    });
    addNewBtn.addEventListener("click", () => {
      const input = document.getElementById("newClientServiceArea");
      const statusEl = document.getElementById("previewNewStatus");
      const entry = (lastPreviewEntry.add || input.value.trim());
      if (!entry) { setPreviewStatus(statusEl, 'Nothing to add'); return; }
      appendEntryToInput(input, entry);
      setPreviewStatus(statusEl, `Added ${entry} to Service Area`);
    });
  }
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(location)}&format=json&limit=3`);
    const data = await res.json();
    
    if(data.length === 0) {
      statusDiv.innerHTML = "‚ùå Location not found.";
      return null;
    }
    
    const top = data[0];
    const confirmed = confirm(`Is this correct?\n\n${top.display_name}\n\nLat: ${top.lat}, Lon: ${top.lon}`);
    
    if(!confirmed) {
      statusDiv.innerHTML = "‚ö†Ô∏è Try a different location.";
      return null;
    }
    
    statusDiv.innerHTML = `‚úì Location confirmed`;
    return [parseFloat(top.lat), parseFloat(top.lon)];
  } catch(e) {
    statusDiv.innerHTML = "‚ö†Ô∏è Error: " + e.message;
    return null;
  }
}

// ADD CLIENT
document.getElementById("saveClientBtn").addEventListener("click", async () => {
  const name = document.getElementById("newClientName").value.trim();
  const industry = document.getElementById("newClientIndustry").value.trim();
  const location = document.getElementById("newClientLocation").value.trim();
  const serviceArea = document.getElementById("newClientServiceArea").value.trim();
  
  if(!name || !industry || !location) { alert("Fill in all fields"); return; }
  
  const statusDiv = document.getElementById("geocodeStatus");
  const coords = await geocodeAndValidate(location);
  if(!coords) return;
  
  statusDiv.innerHTML = "üíæ Saving...";
  
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "addClient", data: { name, industry, location, serviceArea, lat: coords[0], lng: coords[1] } })
    });
    
    const result = await response.json();
    if(result.success) {
      statusDiv.innerHTML = "‚úÖ Added! Refreshing...";
      setTimeout(() => location.reload(), 1500);
    } else {
      statusDiv.innerHTML = "‚ùå " + result.error;
    }
  } catch(e) {
    statusDiv.innerHTML = "‚ùå " + e.message;
  }
});

// DELETE
function populateDeleteDropdown() {
  const select = document.getElementById("clientToDelete");
  select.innerHTML = "<option value=''>Select client...</option>";
  clients.forEach((c, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = c[0];
    select.appendChild(opt);
  });
}

document.getElementById("clientToDelete").addEventListener("change", (e) => {
  document.getElementById("confirmDeleteBtn").disabled = e.target.value === "";
});

document.getElementById("confirmDeleteBtn").addEventListener("click", async () => {
  const idx = parseInt(document.getElementById("clientToDelete").value);
  if(isNaN(idx)) return;
  
  const client = clients[idx];
  if(!confirm(`Delete "${client[0]}"?`)) return;
  
  const statusDiv = document.getElementById("deleteStatus");
  statusDiv.innerHTML = "‚è≥ Deleting...";
  statusDiv.style.display = "block";
  
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "deleteClient", data: { clientName: client[0] } })
    });
    
    const result = await response.json();
    if(result.success) {
      statusDiv.innerHTML = "‚úÖ Deleted!";
      setTimeout(() => location.reload(), 1500);
    } else {
      statusDiv.innerHTML = "‚ùå " + result.error;
    }
  } catch(e) {
    statusDiv.innerHTML = "‚ùå " + e.message;
  }
});

// TRASH
document.getElementById("trashBtn").addEventListener("click", async () => {
  const trashView = document.getElementById("trashView");
  trashView.style.display = trashView.style.display === "none" ? "block" : "none";
  
  if(trashView.style.display === "block") {
    const trashList = document.getElementById("trashList");
    trashList.innerHTML = "Loading...";
    
    try {
      const response = await fetch(APPS_SCRIPT_URL, {
        method: "POST",
        body: JSON.stringify({ action: "getTrash" })
      });
      
      const result = await response.json();
      
      if(result.success && result.trash && result.trash.length > 0) {
        trashList.innerHTML = result.trash.map((item, idx) => `
          <div style="padding:8px; border-bottom:1px solid #eee;">
            <b>${item[0]}</b><br><small>${item[1]} | ${item[2]}</small>
            <div style="margin-top:5px;">
              <button class="restoreBtn" data-idx="${idx}" style="padding:3px 6px; background:#27ae60; color:white; border:none; border-radius:2px; cursor:pointer; font-size:10px; margin-right:3px;">Restore</button>
              <button class="deletePermBtn" data-idx="${idx}" style="padding:3px 6px; background:#c0392b; color:white; border:none; border-radius:2px; cursor:pointer; font-size:10px;">Delete</button>
            </div>
          </div>
        `).join("");
        
        document.querySelectorAll(".restoreBtn").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            if(confirm("Restore?")) await restoreClient(parseInt(e.target.dataset.idx));
          });
        });
        
        document.querySelectorAll(".deletePermBtn").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            if(confirm("Permanently delete?")) await permanentlyDeleteClient(parseInt(e.target.dataset.idx));
          });
        });
      } else {
        trashList.innerHTML = "Empty";
      }
    } catch(e) {
      trashList.innerHTML = "Error: " + e.message;
    }
  }
});

async function restoreClient(idx) {
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "restoreClient", index: idx })
    });
    const result = await response.json();
    if(result.success) setTimeout(() => location.reload(), 1500);
  } catch(e) {}
}

async function permanentlyDeleteClient(idx) {
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "permanentlyDelete", index: idx })
    });
    const result = await response.json();
    if(result.success) setTimeout(() => location.reload(), 1500);
  } catch(e) {}
}

// BUTTON LISTENERS
document.getElementById("addClientBtn").addEventListener("click", () => {
  const form = document.getElementById("addClientForm");
  form.style.display = form.style.display === "none" ? "block" : "none";
});

document.getElementById("editClientBtn").addEventListener("click", () => {
  const form = document.getElementById("editClientForm");
  form.style.display = form.style.display === "none" ? "block" : "none";
  if(form.style.display === "block") populateEditDropdown();
});

// EDIT CLIENT DROPDOWN
function populateEditDropdown() {
  const select = document.getElementById("clientToEdit");
  select.innerHTML = "<option value=''>Select client to edit...</option>";
  clients.forEach((c, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = c[0];
    select.appendChild(opt);
  });
}

document.getElementById("clientToEdit").addEventListener("change", (e) => {
  const idx = parseInt(e.target.value);
  if(isNaN(idx)) {
    document.getElementById("editClientName").disabled = true;
    document.getElementById("editClientIndustry").disabled = true;
    document.getElementById("editClientLocation").disabled = true;
    document.getElementById("editClientServiceArea").disabled = true;
    document.getElementById("saveEditBtn").disabled = true;
    document.getElementById("previewEditAreaBtn").disabled = true;
    document.getElementById("addEditAreaBtn").disabled = true;
    // Clear any existing preview or service area visualization
    clearPreviewLayer();
    if (window.__editServiceAreaLayer) {
      try { map.removeLayer(window.__editServiceAreaLayer); } catch(_) {}
      window.__editServiceAreaLayer = null;
    }
    return;
  }
  
  const client = clients[idx];
  document.getElementById("editClientName").value = client[0];
  document.getElementById("editClientIndustry").value = client[1];
  document.getElementById("editClientLocation").value = client[2];
  document.getElementById("editClientServiceArea").value = client[3] || "";
  
  document.getElementById("editClientName").disabled = false;
  document.getElementById("editClientIndustry").disabled = false;
  document.getElementById("editClientLocation").disabled = false;
  document.getElementById("editClientServiceArea").disabled = true;
  document.getElementById("saveEditBtn").disabled = false;
  document.getElementById("previewEditAreaBtn").disabled = false;
  document.getElementById("addEditAreaBtn").disabled = false;
  document.getElementById("toggleEditAreaEdit").disabled = false;
  document.getElementById("areaSearchEdit").disabled = false;
  
  // Show existing service areas on the map
  (async () => {
    clearPreviewLayer();
    if (window.__editServiceAreaLayer) {
      try { map.removeLayer(window.__editServiceAreaLayer); } catch(_) {}
    }
    const serviceArea = client[3] || "";
    if (!serviceArea) return;
    const entries = [...new Set(normalizeServiceAreaInput(serviceArea))].slice(0, 12);
    if (entries.length === 0) return;
    
    const group = L.featureGroup().addTo(map);
    const features = [];
    const labels = [];
    for (const e of entries) {
      try {
        const result = await fetchPolygonForEntry(e);
        if (!result) continue;
        features.push(result.feature);
        labels.push(result.label);
      } catch(_) {}
    }
    if (features.length === 0) return;
    
    // Render union
    let unionFeat = features[0];
    if (typeof turf !== 'undefined') {
      try {
        for (let i=1;i<features.length;i++) {
          const u = turf.union(unionFeat, features[i]);
          if (u) unionFeat = u;
        }
      } catch(_) {}
    }
    try {
      L.geoJSON(unionFeat, { style: { color: '#f39c12', weight: 2, fillColor: '#f39c12', fillOpacity: 0.15 }, interactive: false, pane: 'serviceAreaPane' }).addTo(group);
    } catch(_) {}
    
    // Add pins and tooltips
    const pinIcon = L.icon({ iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIzNiIgdmlld0JveD0iMCAwIDI0IDM2Ij48ZGVmcz48ZmlsdGVyIGlkPSJzaGFkb3ciPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHN0ZERldmlhdGlvbj0iMiIvPjxmZU9mZnNldCBkeD0iMCIgZHk9IjIiIHJlc3VsdD0ib2Zmc2V0Ymx1ciIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSIjMDAwIiBmbG9vZC1vcGFjaXR5PSIwLjMiLz48ZmVDb21wb3NpdGUgaW4yPSJvZmZzZXRibHVyIiBvcGVyYXRvcj0iaW4iLz48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj0iU291cmNlR3JhcGhpYyIvPjwvZmVNZXJnZT48L2ZpbHRlcj48L2RlZnM+PGcgZmlsdGVyPSJ1cmwoI3NoYWRvdykiPjxwYXRoIGZpbGw9IiNmMzljMTIiIGQ9Ik0xMiAwQzUuNCAwIDAgNS40IDAgMTJjMCA4IDggMTYgMTIgMjQgNC04IDEyLTE2IDEyLTI0IDAtNi42LTUuNC0xMi0xMi0xMnptMCAxNmMtMi4yIDAtNC0xLjgtNC00czEuOC00IDQtNCA0IDEuOCA0IDQtMS44IDQtNCA0eiIvPjwvZz48L3N2Zz4=', iconSize: [24, 36], iconAnchor: [12, 36], popupAnchor: [0, -36] });
    for (let i=0; i<features.length; i++) {
      const feat = features[i];
      let lat = null, lon = null;
      try {
        if (typeof turf !== 'undefined' && turf.center) {
          const center = turf.center(feat);
          if (center?.geometry?.coordinates) { [lon, lat] = center.geometry.coordinates; }
        }
      } catch(_) {}
      if (!lat || !lon) {
        try {
          const bbox = turf.bbox ? turf.bbox(feat) : null;
          if (bbox) { lon = (bbox[0]+bbox[2])/2; lat = (bbox[1]+bbox[3])/2; }
        } catch(_) {}
      }
      if (lat && lon) {
        L.marker([lat, lon], { icon: pinIcon, interactive: false }).addTo(group).bindTooltip(labels[i], { permanent: false, direction: 'top' });
      }
    }
    
    window.__editServiceAreaLayer = group;
    try { map.fitBounds(group.getBounds(), { padding: [50, 50] }); } catch(_) {}
  })();
});

// Preview/add service area on Edit Client form
const previewEditBtn = document.getElementById("previewEditAreaBtn");
const addEditBtn = document.getElementById("addEditAreaBtn");
if (previewEditBtn && addEditBtn) {
  previewEditBtn.addEventListener("click", async () => {
    if (previewEditBtn.disabled) return;
    const src = document.getElementById("areaSearchEdit").value.trim();
    const entry = src || document.getElementById("editClientServiceArea").value.trim();
    await previewServiceAreaEntry(entry, document.getElementById("previewEditStatus"), 'edit');
  });
  addEditBtn.addEventListener("click", () => {
    if (addEditBtn.disabled) return;
    const input = document.getElementById("editClientServiceArea");
    const statusEl = document.getElementById("previewEditStatus");
    const entry = (lastPreviewEntry.edit || input.value.trim());
    if (!entry) { setPreviewStatus(statusEl, 'Nothing to add'); return; }
    const added = appendEntryToInput(input, entry, statusEl);
    if (added) {
      dedupeServiceAreaInput(input);
      setPreviewStatus(statusEl, `Added ${entry} to Service Area`);
    }
  });
}

// SAVE EDIT
document.getElementById("saveEditBtn").addEventListener("click", async () => {
  const idx = parseInt(document.getElementById("clientToEdit").value);
  if(isNaN(idx)) return;
  
  const originalClient = clients[idx];
  const newName = document.getElementById("editClientName").value.trim();
  const newIndustry = document.getElementById("editClientIndustry").value.trim();
  const newLocation = document.getElementById("editClientLocation").value.trim();
  const newServiceArea = document.getElementById("editClientServiceArea").value.trim();
  
  if(!newName || !newIndustry || !newLocation) {
    alert("Please fill in Name, Industry, and Location");
    return;
  }
  
  if(!confirm(`Update "${originalClient[0]}"?`)) return;
  
  const statusDiv = document.getElementById("editStatus");
  statusDiv.innerHTML = "‚è≥ Updating...";
  statusDiv.style.display = "block";
  
  if(!APPS_SCRIPT_URL) {
    statusDiv.innerHTML = "Apps Script not configured.";
    return;
  }
  
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({
        action: "editClient",
        data: {
          originalName: originalClient[0],
          name: newName,
          industry: newIndustry,
          location: newLocation,
          serviceArea: newServiceArea,
          lat: originalClient[4][0],
          lng: originalClient[4][1]
        }
      })
    });
    
    const result = await response.json();
    if(result.success) {
      statusDiv.innerHTML = "‚úÖ Updated! Refreshing...";
      setTimeout(() => location.reload(), 1500);
    } else {
      statusDiv.innerHTML = "‚ùå Error: " + result.error;
    }
  } catch(e) {
    statusDiv.innerHTML = "‚ùå Error: " + e.message;
  }
});

document.getElementById("deleteClientBtn").addEventListener("click", () => {
  const form = document.getElementById("deleteClientForm");
  form.style.display = form.style.display === "none" ? "block" : "none";
  if(form.style.display === "block") populateDeleteDropdown();
});

document.querySelectorAll(".closeForm").forEach(btn => {
  btn.addEventListener("click", (e) => {
    document.getElementById(e.target.dataset.form).style.display = "none";
    // Clear preview layer and service area layers
    clearPreviewLayer();
    if (window.__editServiceAreaLayer) {
      try { map.removeLayer(window.__editServiceAreaLayer); } catch(_) {}
      window.__editServiceAreaLayer = null;
    }
    if (window.__serviceAreaLayers) {
      Object.values(window.__serviceAreaLayers).forEach(layer => {
        try { map.removeLayer(layer); } catch(_) {}
      });
      window.__serviceAreaLayers = {};
    }
  });
});

// Toggle edit buttons for Service Area inputs
const toggleNew = document.getElementById('toggleNewAreaEdit');
if (toggleNew) {
  toggleNew.addEventListener('click', () => {
    const input = document.getElementById('newClientServiceArea');
    input.disabled = !input.disabled;
    toggleNew.textContent = input.disabled ? '‚úé' : '‚úì';
  });
}
const toggleEdit = document.getElementById('toggleEditAreaEdit');
if (toggleEdit) {
  toggleEdit.addEventListener('click', () => {
    const input = document.getElementById('editClientServiceArea');
    input.disabled = !input.disabled;
    toggleEdit.textContent = input.disabled ? '‚úé' : '‚úì';
  });
}

function buildLegend(){
  const box=document.getElementById("legendBox");
  box.innerHTML="<button id='resetLegend'>Reset All</button><b>Industry</b><br><br>";
  const set=new Set();
  clients.forEach(c=>c[1].split(",").forEach(i=>set.add(i.trim())));
  [...set].sort().forEach(ind=>{
    legendStatus[ind]=legendStatus[ind]||false;
    const div=document.createElement("div");
    div.className="legend-item";
    div.innerHTML=`<div class="legend-color" style="background:${colors[ind]||"#666"}"></div>${ind}`;
    div.style.textDecoration=legendStatus[ind]?'line-through':'none';
    div.onclick=()=>{
      legendStatus[ind]=!legendStatus[ind];
      div.style.textDecoration=legendStatus[ind]?'line-through':'none';
      applyFilters();
    };
    box.appendChild(div);
  });

  document.getElementById("resetLegend").onclick = () => {
    Object.keys(legendStatus).forEach(k=>legendStatus[k]=false);
    document.querySelectorAll(".legend-item").forEach(d=>d.style.textDecoration="none");
    applyFilters();
  }
}

// INIT
document.getElementById("searchBox").addEventListener("input",applyFilters);
document.getElementById("toggleChartType").addEventListener("click",()=>{
  currentChartType=currentChartType==="bar"?"pie":"bar";
  document.getElementById("toggleChartType").innerText=currentChartType==="bar"?"Switch to Pie Chart":"Switch to Bar Chart";
  updateChart(filteredClients);
});

});
</script>
</body>
</html>