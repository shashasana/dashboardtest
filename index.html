<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Client Industry Dashboard</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0/osmtogeojson.min.js"></script>
<!-- LOGIN SCRIPT START -->
<script>
  let isAuthenticated = false;
  const password = "masternino"; // change to your password
  if (!sessionStorage.getItem("loggedIn")) {
    const userPass = prompt("Enter password:");
    if (userPass === password) {
      sessionStorage.setItem("loggedIn", "true");
      isAuthenticated = true;
    } else {
      isAuthenticated = false;
    }
  } else {
    isAuthenticated = true;
  }
</script>
<!-- LOGIN SCRIPT END -->
<style>
body { margin:0; font-family: Arial, sans-serif; height:100vh; }
#container { display:grid; grid-template-columns:360px 1fr; height:100vh; }
#accessDenied { display: none; text-align: center; padding: 50px; font-size: 24px; color: #c0392b; }
#accessDenied.show { display: block; }
#sidebar { background:#f5f5f5; padding:15px; overflow-y:auto; border-right:1px solid #ccc; display:flex; flex-direction:column; }
#sidebar input, #sidebar select, #sidebar button { width:100%; padding:8px; margin-bottom:10px; box-sizing:border-box; }
#sidebar select[multiple] { height:250px; min-height:150px; overflow-y:auto; display:none; }
#legendBox { margin:10px 0; padding:10px; background:white; border:1px solid #ccc; border-radius:5px; font-size:13px; display:flex; flex-direction:column; }
.legend-item { display:flex; align-items:center; margin-bottom:6px; cursor:pointer; }
.legend-color { width:14px; height:14px; margin-right:8px; border:1px solid #000; }
#resetLegend { margin-bottom:10px; padding:5px; background:#e74c3c; color:white; border:none; border-radius:3px; cursor:pointer; }
#resetLegend:hover { background:#c0392b; }
#map { width:100%; height:100%; }
#chartContainer { width:100%; height:450px; margin-bottom:10px; }
#industryChart { width:100%; height:100%; }
</style>
</head>
<body>
<div id="container">
  <div id="sidebar">
    <h2>Client Dashboard</h2>
    <div id="loadingStatus" style="padding:10px; background:#fff3cd; border-radius:5px; margin-bottom:10px; display:none; color:#856404;">
      ‚è≥ Loading data...
    </div>
    <div id="controlButtons" style="display:flex; gap:5px; margin-bottom:15px;">
      <button id="addClientBtn" style="flex:1; padding:8px; background:#27ae60; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">+ Add</button>
      <button id="editClientBtn" style="flex:1; padding:8px; background:#3498db; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">‚úé Edit</button>
      <button id="deleteClientBtn" style="flex:1; padding:8px; background:#e74c3c; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">üóë Delete</button>
      <button id="trashBtn" style="flex:1; padding:8px; background:#95a5a6; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">üì¶ Trash</button>
    </div>

    <!-- Add Client Form -->
    <div id="addClientForm" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Add New Client</b>
        <button class="closeForm" data-form="addClientForm" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <input type="text" id="newClientName" placeholder="Client Name" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <input type="text" id="newClientIndustry" placeholder="Industry" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <input type="text" id="newClientLocation" placeholder="Location (e.g., Austin, TX)" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <input type="text" id="newClientServiceArea" placeholder="Service Area" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
      <div style="display:flex; gap:6px; margin-bottom:8px;">
        <button id="previewNewAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;">üîç Preview Area</button>
        <button id="addNewAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;">‚ûï Add to Service Area</button>
      </div>
      <div id="previewNewStatus" style="margin-bottom:8px; font-size:12px; color:#555; display:none;"></div>
      <button id="saveClientBtn" style="width:100%; padding:8px; background:#27ae60; color:white; border:none; border-radius:3px; cursor:pointer;">Save Client</button>
      <div id="geocodeStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <!-- Edit Client Form -->
    <div id="editClientForm" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Edit Client</b>
        <button class="closeForm" data-form="editClientForm" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <select id="clientToEdit" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
        <option value="">Select client to edit...</option>
      </select>
      <input type="text" id="editClientName" placeholder="Client Name" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <input type="text" id="editClientIndustry" placeholder="Industry" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <input type="text" id="editClientLocation" placeholder="Location" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <input type="text" id="editClientServiceArea" placeholder="Service Area" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;" disabled>
      <div style="display:flex; gap:6px; margin-bottom:8px;">
        <button id="previewEditAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;" disabled>üîç Preview Area</button>
        <button id="addEditAreaBtn" type="button" style="flex:1; padding:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; border-radius:3px;" disabled>‚ûï Add to Service Area</button>
      </div>
      <div id="previewEditStatus" style="margin-bottom:8px; font-size:12px; color:#555; display:none;"></div>
      <button id="saveEditBtn" style="width:100%; padding:8px; background:#3498db; color:white; border:none; border-radius:3px; cursor:pointer;" disabled>Save Changes</button>
      <div id="editStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <!-- Delete Client Form -->
    <div id="deleteClientForm" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Delete Client</b>
        <button class="closeForm" data-form="deleteClientForm" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <select id="clientToDelete" style="width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; border:1px solid #ccc; border-radius:3px;">
        <option value="">Select client to delete...</option>
      </select>
      <button id="confirmDeleteBtn" style="width:100%; padding:8px; background:#e74c3c; color:white; border:none; border-radius:3px; cursor:pointer;" disabled>Delete Selected</button>
      <div id="deleteStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <!-- Trash View -->
    <div id="trashView" style="display:none; background:white; border:1px solid #ccc; padding:10px; border-radius:5px; margin-bottom:15px;">
      <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <b>Trash</b>
        <button class="closeForm" data-form="trashView" style="background:none; border:none; cursor:pointer; font-size:16px;">√ó</button>
      </div>
      <div id="trashList" style="max-height:200px; overflow-y:auto; font-size:12px;"></div>
      <div id="trashStatus" style="margin-top:8px; padding:8px; background:#ecf0f1; border-radius:3px; display:none; font-size:12px;"></div>
    </div>

    <input type="text" id="searchBox" placeholder="Search client / industry / location..." style="margin-bottom:15px;">
    <div id="legendBox"></div>
    <button id="toggleChartType">Switch to Pie Chart</button>
    <div id="chartContainer"><canvas id="industryChart"></canvas></div>
  </div>
  <div id="map"></div>
</div>
<div id="accessDenied">
  <h1 style="margin-top:50px; color:#c0392b;">Access Denied</h1>
  <p>Please reload the page and enter the correct password.</p>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // Check authentication first
  console.log("isAuthenticated:", isAuthenticated);
  if (!isAuthenticated) {
    console.log("Access denied, hiding container");
    document.getElementById("container").style.display = "none";
    document.getElementById("accessDenied").classList.add("show");
    return;
  }
  
  console.log("Authenticated, showing dashboard");
  document.getElementById("accessDenied").style.display = "none";

// MAP INIT
const map = L.map("map").setView([39.5,-98.35],4);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{ attribution:"&copy; OpenStreetMap" }).addTo(map);

// COLORS
const colors = {
  "Speciality (Niche)":"#e74c3c","Window Treatments & Coverings":"#3498db","Home Organization & Closets":"#2ecc71",
  "Kitchens":"#f39c12","Pools":"#1abc9c","Roofing":"#9b59b6","Construction":"#34495e",
  "Painters":"#ff6f61","Fencing":"#16a085","Floor Coating":"#8e44ad","Landscaping":"#27ae60",
  "Cleaning":"#00bcd4","Pest Control":"#795548","Flooring":"#607d8b","Events Place":"#d35400",
  "Power Washing":"#00acc1","Home Improvement":"#5e35b1"
};

// GOOGLE SHEET CONFIG
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTLuqA1azB3yyRdwNLBIV5WLcO7CezuoMD4yEOtk-MF7V8RTq2ehxR5JnFOCGDQ4-v10TVtmpnTaSn2/pub?output=csv";
const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbx7MUHb_Ee8H_Qajwc4OEh4-U5ZLtIDU0m9Je2N9yzJHYPwmitnhzJ5Z08e3gVcfcKX/exec";

// GEOCODE LOCATION
async function geocodeLocation(location) {
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(location)}&format=json&limit=1`);
    const data = await res.json();
    if(data.length > 0) {
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }
  } catch(e) {}
  return [39.5, -98.35];
}

// PARSE CSV
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cell = "";
  let insideQuotes = false;
  
  for(let i = 0; i < text.length; i++) {
    const char = text[i];
    const nextChar = text[i + 1];
    
    if(char === '"') {
      if(insideQuotes && nextChar === '"') {
        cell += '"';
        i++;
      } else {
        insideQuotes = !insideQuotes;
      }
    } else if(char === ',' && !insideQuotes) {
      row.push(cell.trim());
      cell = "";
    } else if((char === '\n' || char === '\r') && !insideQuotes) {
      if(cell || row.length > 0) {
        row.push(cell.trim());
        if(row.some(c => c)) rows.push(row);
        row = [];
        cell = "";
      }
      if(char === '\r' && nextChar === '\n') i++;
    } else {
      cell += char;
    }
  }
  if(cell || row.length > 0) {
    row.push(cell.trim());
    if(row.some(c => c)) rows.push(row);
  }
  return rows;
}

// FETCH CLIENTS
async function fetchClientsFromSheet() {
  try {
    let csv = null;
    try {
      const res = await fetch(CSV_URL);
      if(res.ok) csv = await res.text();
    } catch(e) {}
    
    if(!csv) return [];
    
    const rows = parseCSV(csv);
    if(rows.length < 2) return [];
    
    const parsed = [];
    for(let i = 1; i < rows.length; i++) {
      const cells = rows[i];
      if(cells.length >= 3 && cells[0]) {
        const name = cells[0].replace(/^"|"$/g, '').trim();
        const industry = (cells[1] || "Unknown").replace(/^"|"$/g, '').trim();
        const location = (cells[2] || "Unknown").replace(/^"|"$/g, '').trim();
        const lat = cells[4] ? parseFloat(cells[4]) : null;
        const lng = cells[5] ? parseFloat(cells[5]) : null;
        
        const serviceArea = (cells[3] || "").replace(/^"|"$/g, '').trim();
        let coords = [39.5, -98.35];
        if(lat && lng && !isNaN(lat) && !isNaN(lng)) {
          coords = [lat, lng];
        } else {
          coords = await geocodeLocation(location);
        }
        parsed.push([name, industry, location, serviceArea, coords]);
      }
    }
    return parsed;
  } catch(e) {
    return [];
  }
}

let clients = [];
let filteredClients = [];
let legendStatus = {};
let markers = [], chart=null, currentChartType="bar";

(async () => {
  clients = await fetchClientsFromSheet();
  // Localhost-only demo: inject service areas for preview without sheet changes
  if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
    try {
      const demo = "49501, 49503, Grand Rapids, MI";
      clients = clients.map(c => {
        if ((c[0]||"").toLowerCase().includes("north shore brick")) {
          // c = [name, industry, location, serviceArea, coords]
          c[3] = c[3] && c[3].trim().length ? c[3] : demo;
        }
        return c;
      });
    } catch(_) {}
  }
  setupFilters();
  buildLegend();
  loadMarkers(clients);
})();

// FETCH WEATHER
async function fetchWeather(lat, lng) {
  try {
    const res = await fetch(`/api/weather?lat=${lat}&lng=${lng}`);
    if (!res.ok) return { temp:"N/A", tzOffset:0 };
    const d = await res.json();
    return {
      temp: typeof d?.main?.temp === "number" ? d.main.temp.toFixed(1) : "N/A",
      tzOffset: typeof d?.timezone === "number" ? d.timezone : 0
    };
  } catch(e) {
    return { temp:"N/A", tzOffset:0 };
  }
}

// FORMAT LOCAL TIME
function formatLocalTime(offsetSeconds) {
  const utc = new Date().getTime() + new Date().getTimezoneOffset()*60000;
  const local = new Date(utc + offsetSeconds*1000);
  let hours = local.getHours();
  const mins = String(local.getMinutes()).padStart(2,'0');
  const ampm = hours>=12?"PM":"AM";
  const hr12 = hours%12||12;
  return `${hr12}:${mins} ${ampm}`;
}

// SETUP POPUP
async function setupPopup(marker, client) {
  const [name, inds, loc, serviceArea, coords] = client;
  marker.bindPopup(`<b>${name}</b><br>Industry: ${inds}<br>Location: ${loc}<br>Loading‚Ä¶`);
  const update = async () => {
    try {
      const {temp, tzOffset} = await fetchWeather(coords[0], coords[1]);
      const timeStr = formatLocalTime(tzOffset);
      marker.getPopup().setContent(`<b>${name}</b><br>Industry: ${inds}<br>Location: ${loc}<br>Local Time: ${timeStr}<br>Temp: ${temp}¬∞C`);
    } catch(_) {
      marker.getPopup().setContent(`<b>${name}</b><br>Industry: ${inds}<br>Location: ${loc}<br>Local Time: N/A<br>Temp: N/A`);
    }
  };
  await update();
  setInterval(update, 10*60*1000);

  // Show popup on hover; click is reserved for service-area polygons
  marker.on('mouseover', () => {
    try { marker.openPopup(); } catch(_) {}
  });
  marker.on('mouseout', () => {
    try { marker.closePopup(); } catch(_) {}
  });
}

// --- Service Area (ZIP/Location) Polygons ---
const SERVICE_AREA_STYLE = {
  color: '#e74c3c',
  weight: 2,
  fillColor: '#e74c3c',
  fillOpacity: 0.15  // Reduced from 0.25 to be more transparent
};

const OVERLAP_STYLE = {
  color: '#e74c3c',
  weight: 2,
  dashArray: '4 4',
  fillColor: '#e74c3c',
  fillOpacity: 0.15
};

function getServiceAreaCache() {
  try { return JSON.parse(localStorage.getItem('serviceAreaCache')||'{}'); } catch(_) { return {}; }
}
function setServiceAreaCache(cache) {
  try { localStorage.setItem('serviceAreaCache', JSON.stringify(cache)); } catch(_) {}
}

// --- Service area preview helpers ---
let previewLayer = null;
const lastPreviewEntry = { add: null, edit: null };

function clearPreviewLayer() {
  if (previewLayer) {
    try { map.removeLayer(previewLayer); } catch(_) {}
    previewLayer = null;
  }
}

function appendEntryToInput(inputEl, entry) {
  const parts = inputEl.value.split(',').map(p => p.trim()).filter(Boolean);
  if (!parts.includes(entry)) parts.push(entry);
  inputEl.value = parts.join(', ');
}

function setPreviewStatus(el, msg) {
  if (!el) return;
  el.style.display = 'block';
  el.textContent = msg;
}

async function previewServiceAreaEntry(entry, statusEl, contextKey) {
  if (!entry) {
    setPreviewStatus(statusEl, 'Enter a ZIP or place');
    return null;
  }
  const attempts = normalizeServiceAreaInput(entry).slice(0, 10); // try up to 10 entries
  if (attempts.length === 0) {
    setPreviewStatus(statusEl, 'Enter a ZIP or place');
    return null;
  }
  setPreviewStatus(statusEl, 'Searching‚Ä¶');
  clearPreviewLayer();
  for (const attempt of attempts) {
    try {
      const result = await fetchPolygonForEntry(attempt);
      if (!result || !result.feature) continue;
      previewLayer = L.geoJSON(result.feature, { style: SERVICE_AREA_STYLE }).addTo(map);
      try { map.fitBounds(previewLayer.getBounds(), { padding: [20, 20] }); } catch(_) {}
      setPreviewStatus(statusEl, `Previewing: ${result.label || attempt}`);
      lastPreviewEntry[contextKey] = attempt;
      return result;
    } catch(err) {
      console.error('[PREVIEW] Error for', attempt, err);
    }
  }
  setPreviewStatus(statusEl, 'No polygon found');
  return null;
}

function normalizeServiceAreaInput(str) {
  if (!str) return [];
  const lines = str.replace(/\r\n/g,'\n').split(/\n/).map(s=>s.trim()).filter(Boolean);
  const out = [];
  for (const line of lines) {
    // Split by comma first
    const tokens = line.split(',').map(t=>t.trim()).filter(Boolean);
    // Separate ZIPs from city/state
    const zips = tokens.filter(isZip);
    const nonZips = tokens.filter(t=>!isZip(t));
    
    // Add each ZIP separately
    zips.forEach(z => out.push(z));
    
    // Add non-ZIP tokens as separate entries or join them
    if (nonZips.length > 0) {
      out.push(nonZips.join(', '));
    }
  }
  return out;
}

function isZip(s) { return /^\d{5}$/.test(s); }

async function fetchPolygonForEntry(entry) {
  // Returns { feature, label } where feature is a GeoJSON Feature (Polygon/MultiPolygon)
  const cache = getServiceAreaCache();
  if (cache[entry]) {
    const c = cache[entry];
    if (c.type === 'feature') {
      return { feature: c.feature, label: c.label || entry };
    }
  }

  // Fetch from backend (Google Apps Script handles Nominatim lookup)
  const url = `${APPS_SCRIPT_URL}?action=getPolygon&entry=${encodeURIComponent(entry)}`;
  console.log(`[POLY-FETCH] Backend URL for ${entry}: ${url}`);
  
  try {
    await new Promise(r=>setTimeout(r, 100)); // Small delay to avoid overwhelming backend
    const res = await fetch(url);
    const data = await res.json();
    console.log(`[POLY-FETCH] Backend response for ${entry}:`, data);
    
    if (data.feature && data.label) {
      cache[entry] = { type:'feature', feature: data.feature, label: data.label };
      setServiceAreaCache(cache);
      return { feature: data.feature, label: data.label };
    } else if (data.error) {
      console.error(`[POLY-FETCH] Backend error for ${entry}:`, data.error);
    }
  } catch(err) {
    console.error(`[POLY-FETCH] Fetch error for ${entry}:`, err);
  }

  // Overpass fallback: fetch polygon for postal_code
  if (isZip(entry)) {
    try {
      const overpassQuery = `data=[out:json][timeout:10];(relation["boundary"="administrative"]["postal_code"="${entry}"];relation["boundary"="postal_code"]["postal_code"="${entry}"];way["postal_code"="${entry}"];);out body;>;out skel qt;`;
      const overpassUrl = `https://overpass-api.de/api/interpreter?${overpassQuery}`;
      console.log(`[POLY-FETCH] Overpass URL for ${entry}: ${overpassUrl}`);
      await new Promise(r=>setTimeout(r, 250));
      const res = await fetch(overpassUrl, { headers: { 'Accept': 'application/json' } });
      const data = await res.json();
      if (data?.elements?.length) {
        // Convert Overpass result to GeoJSON via simple interpretation
        const geo = osmtogeojson(data);
        if (geo?.features?.length) {
          // Take first polygon/multipolygon feature
          const poly = geo.features.find(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
          if (poly) {
            // Try to get a better label from previous Nominatim attempt
            let label = entry;
            if (Array.isArray(data?.elements) && data.elements.length > 0) {
              const tags = data.elements[0].tags;
              if (tags?.name) label = `${tags.name} ${entry}`;
            }
            const feature = { type:'Feature', geometry: poly.geometry, properties:{ label } };
            cache[entry] = { type:'feature', feature, label };
            setServiceAreaCache(cache);
            console.log(`[POLY-FETCH] Using Overpass polygon for ${entry}`);
            return { feature, label };
          }
        }
      }
    } catch(err) {
      console.error(`[POLY-FETCH] Overpass error for ${entry}:`, err);
    }

    // Final fallback: US Census TIGER ZIP boundaries via public API
    try {
      const censusUrl = `https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Current/MapServer/2/query?where=ZCTA5='${entry}'&outFields=*&outSR=4326&f=geojson`;
      console.log(`[POLY-FETCH] Census TIGER URL for ${entry}: ${censusUrl}`);
      await new Promise(r=>setTimeout(r, 500));
      const res = await fetch(censusUrl);
      if (!res.ok) {
        console.error(`[POLY-FETCH] Census TIGER HTTP ${res.status} for ${entry}`);
        return null;
      }
      const data = await res.json();
      console.log(`[POLY-FETCH] Census TIGER response:`, data);
      if (data?.features?.length) {
        const poly = data.features[0];
        if (poly.geometry && (poly.geometry.type === 'Polygon' || poly.geometry.type === 'MultiPolygon')) {
          const label = entry; // ZIP only for Census data
          const feature = { type:'Feature', geometry: poly.geometry, properties:{ label } };
          cache[entry] = { type:'feature', feature, label };
          setServiceAreaCache(cache);
          console.log(`[POLY-FETCH] Using Census TIGER polygon for ${entry}`);
          return { feature, label };
        }
      }
    } catch(err) {
      console.error(`[POLY-FETCH] Census TIGER error for ${entry}:`, err);
    }
  }
  // No polygon geojson available; skip to avoid boxy fallbacks
  return null;
}

function buildLabel(entry, item) {
  // Format: "City ST ZIP" or just "ZIP" if no city found
  try {
    if (isZip(entry)) {
      const disp = (item?.display_name||'').split(',').map(s=>s.trim());
      // Filter out the ZIP itself from display_name parts
      const parts = disp.filter(p => p !== entry && !/^\d{5}$/.test(p));
      const city = parts[0] || '';
      const state = parts.find(v=>/\b[A-Z]{2}\b/.test(v)) || '';
      // Build clean label without duplicating ZIP
      if (city && state) {
        return `${city} ${state} ${entry}`;
      } else if (city) {
        return `${city} ${entry}`;
      } else {
        return entry; // Just ZIP if no city found
      }
    } else {
      return entry; // keep user-provided for locations
    }
  } catch(_) { return entry; }
}

async function setupServiceAreaOnClick(marker, client) {
  const [name, inds, loc, serviceArea /*string*/, coords] = client;
  console.log(`[SA] Setting up for ${name}, serviceArea: "${serviceArea}"`);
  const entries = [...new Set(normalizeServiceAreaInput(serviceArea))].slice(0, 12);
  console.log(`[SA] Normalized entries:`, entries);
  if (entries.length === 0) {
    console.log(`[SA] No entries, returning`);
    return;
  }
  if (!window.__serviceAreaLayers) window.__serviceAreaLayers = {};

  marker.on('click', async () => {
    console.log(`[SA] Click handler fired for ${name}`);
    const existing = window.__serviceAreaLayers[name];
    if (existing) { try { existing.remove(); } catch(_){} delete window.__serviceAreaLayers[name]; return; }

    const group = L.layerGroup().addTo(map);
    const features = [];
    const labels = [];
    for (const e of entries) {
      console.log(`[SA-FETCH] Fetching polygon for: ${e}`);
      const result = await fetchPolygonForEntry(e);
      console.log(`[SA-FETCH] Got result:`, result);
      if (!result) { console.log(`[SA-FETCH] No result for ${e}`); continue; }
      features.push(result.feature);
      labels.push(result.label);
    }
    console.log(`[SA-RENDER] Got ${features.length}/${entries.length} features`);
    if (features.length === 0) { window.__serviceAreaLayers[name] = group; return; }

    // Compute union for solid combined polygon
    let unionFeat = features[0];
    if (typeof turf !== 'undefined') {
      try {
        for (let i=1;i<features.length;i++) {
          const u = turf.union(unionFeat, features[i]);
          if (u) unionFeat = u;
        }
      } catch(_) {}
    }
    L.geoJSON(unionFeat, { style: SERVICE_AREA_STYLE }).addTo(group);

        // Add a blue pin icon with shadow at each entry center
        const pinIcon = L.icon({
          iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIzNiIgdmlld0JveD0iMCAwIDI0IDM2Ij48ZGVmcz48ZmlsdGVyIGlkPSJzaGFkb3ciPjxmZUdhdXNzaWFuQmx1ciBpbj0iU291cmNlQWxwaGEiIHN0ZERldmlhdGlvbj0iMiIvPjxmZU9mZnNldCBkeD0iMCIgZHk9IjIiIHJlc3VsdD0ib2Zmc2V0Ymx1ciIvPjxmZUZsb29kIGZsb29kLWNvbG9yPSIjMDAwIiBmbG9vZC1vcGFjaXR5PSIwLjMiLz48ZmVDb21wb3NpdGUgaW4yPSJvZmZzZXRibHVyIiBvcGVyYXRvcj0iaW4iLz48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj0iU291cmNlR3JhcGhpYyIvPjwvZmVNZXJnZT48L2ZpbHRlcj48L2RlZnM+PGcgZmlsdGVyPSJ1cmwoI3NoYWRvdykiPjxwYXRoIGZpbGw9IiM0MDk2Q0UiIGQ9Ik0xMiAwQzUuNCAwIDAgNS40IDAgMTJjMCA4IDggMTYgMTIgMjQgNC04IDEyLTE2IDEyLTI0IDAtNi42LTUuNC0xMi0xMi0xMnptMCAxNmMtMi4yIDAtNC0xLjgtNC00czEuOC00IDQtNCA0IDEuOCA0IDQtMS44IDQtNCA0eiIvPjwvZz48L3N2Zz4=',
          iconSize: [24, 36],
          iconAnchor: [12, 36],
          popupAnchor: [0, -36]
        });
        for (let i=0;i<features.length;i++) {
          const feat = features[i];
          let lat = null, lon = null;
          try {
            if (typeof turf !== 'undefined' && turf.center) {
              const center = turf.center(feat);
              if (center?.geometry?.coordinates) {
                [lon, lat] = center.geometry.coordinates;
              }
            }
          } catch(_) {}
          if (!lat || !lon) {
            try {
              const bbox = turf.bbox ? turf.bbox(feat) : null;
              if (bbox) { lon = (bbox[0]+bbox[2])/2; lat = (bbox[1]+bbox[3])/2; }
            } catch(_) {}
          }
          if (lat && lon) {
            L.marker([lat, lon], { icon: pinIcon, interactive:false }).addTo(group).bindTooltip(labels[i], { permanent:false, direction:'top' });
          }
        }

    // Add invisible hover layers for per-entry tooltips
    features.forEach((f, idx) => {
      L.geoJSON(f, { style: { color:'#0000', weight:0, fillOpacity:0, interactive:true } })
        .addTo(group)
        .bindTooltip(labels[idx], { permanent:false, direction:'center' });
    });

    // Draw dashed overlays for overlaps
    if (typeof turf !== 'undefined') {
      for (let i=0;i<features.length;i++) {
        for (let j=i+1;j<features.length;j++) {
          try {
            const inter = turf.intersect(features[i], features[j]);
            if (inter) L.geoJSON(inter, { style: OVERLAP_STYLE }).addTo(group);
          } catch(_) {}
        }
      }
    }

    window.__serviceAreaLayers[name] = group;
  });
}

// LOAD MARKERS
function loadMarkers(data) {
  console.log(`[LOAD] loadMarkers called with ${data.length} clients`);
  markers.forEach(m=>map.removeLayer(m));
  markers=[];
  filteredClients = data;
  // Clear any previously rendered service area layers
  if (window.__serviceAreaLayers) {
    Object.values(window.__serviceAreaLayers).forEach(lg => { try { lg.remove(); } catch(_){} });
    window.__serviceAreaLayers = {};
  }
  data.forEach(item=>{
    const [name, inds, loc, serviceArea, coords] = item;
    console.log(`[LOAD] Marker: ${name}, serviceArea="${serviceArea}", coords=${JSON.stringify(coords)}`);
    const mk = L.circleMarker(coords,{ radius:8, fillColor: colors[inds.split(",")[0].trim()]||"#666", color:"#000", weight:1, fillOpacity:0.9 }).addTo(map);
    mk.industries = inds.split(",").map(i=>i.trim());
    if(mk.industries.some(i=>legendStatus[i])) map.removeLayer(mk);
    setupPopup(mk, item);
    setupServiceAreaOnClick(mk, item);
    markers.push(mk);
  });
  updateChart(data);
}

// UPDATE CHART
function updateChart(data){
  const counts={}, colorArr={};
  data.forEach(c=>{
    c[1].split(",").map(i=>i.trim()).forEach(i=>{ counts[i]=(counts[i]||0)+1; colorArr[i]=colors[i]||"#666"; });
  });
  let labels=Object.keys(counts).sort();
  const values=labels.map(l=>counts[l]);
  const bg=labels.map(l=>colorArr[l]);
  if(chart) chart.destroy();
  chart=new Chart(document.getElementById("industryChart"),{
    type: currentChartType,
    data:{ labels, datasets:[{ data:values, backgroundColor:bg, borderWidth:0 }] },
    options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false }}, scales: currentChartType==="bar"?{y:{beginAtZero:true},x:{display:false}}:{} }
  });
}

// FILTERS
function applyFilters(){
  const s=document.getElementById("searchBox").value.toLowerCase().trim();
  const filtered = clients.filter(c=>{
    const txt=(c[0]+" "+c[1]+" "+c[2]).toLowerCase();
    if(s && !txt.includes(s)) return false; // Search filter
    const industries = c[1].split(",").map(i=>i.trim());
    return !industries.some(ind=>legendStatus[ind]); // Exclude if any industry is hidden
  });
  loadMarkers(filtered);
}

function setupFilters(){}

// GEOCODE & VALIDATE
async function geocodeAndValidate(location) {
  const statusDiv = document.getElementById("geocodeStatus");
  statusDiv.innerHTML = "üîç Geocoding...";
  statusDiv.style.display = "block";
  

  // Preview/add service area on Add Client form
  const previewNewBtn = document.getElementById("previewNewAreaBtn");
  const addNewBtn = document.getElementById("addNewAreaBtn");
  if (previewNewBtn && addNewBtn) {
    previewNewBtn.addEventListener("click", async () => {
      const entry = document.getElementById("newClientServiceArea").value.trim();
      await previewServiceAreaEntry(entry, document.getElementById("previewNewStatus"), 'add');
    });
    addNewBtn.addEventListener("click", () => {
      const input = document.getElementById("newClientServiceArea");
      const statusEl = document.getElementById("previewNewStatus");
      const entry = (lastPreviewEntry.add || input.value.trim());
      if (!entry) { setPreviewStatus(statusEl, 'Nothing to add'); return; }
      appendEntryToInput(input, entry);
      setPreviewStatus(statusEl, `Added ${entry} to Service Area`);
    });
  }
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(location)}&format=json&limit=3`);
    const data = await res.json();
    
    if(data.length === 0) {
      statusDiv.innerHTML = "‚ùå Location not found.";
      return null;
    }
    
    const top = data[0];
    const confirmed = confirm(`Is this correct?\n\n${top.display_name}\n\nLat: ${top.lat}, Lon: ${top.lon}`);
    
    if(!confirmed) {
      statusDiv.innerHTML = "‚ö†Ô∏è Try a different location.";
      return null;
    }
    
    statusDiv.innerHTML = `‚úì Location confirmed`;
    return [parseFloat(top.lat), parseFloat(top.lon)];
  } catch(e) {
    statusDiv.innerHTML = "‚ö†Ô∏è Error: " + e.message;
    return null;
  }
}

// ADD CLIENT
document.getElementById("saveClientBtn").addEventListener("click", async () => {
  const name = document.getElementById("newClientName").value.trim();
  const industry = document.getElementById("newClientIndustry").value.trim();
  const location = document.getElementById("newClientLocation").value.trim();
  const serviceArea = document.getElementById("newClientServiceArea").value.trim();
  
  if(!name || !industry || !location) { alert("Fill in all fields"); return; }
  
  const statusDiv = document.getElementById("geocodeStatus");
  const coords = await geocodeAndValidate(location);
  if(!coords) return;
  
  statusDiv.innerHTML = "üíæ Saving...";
  
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "addClient", data: { name, industry, location, serviceArea, lat: coords[0], lng: coords[1] } })
    });
    
    const result = await response.json();
    if(result.success) {
      statusDiv.innerHTML = "‚úÖ Added! Refreshing...";
      setTimeout(() => location.reload(), 1500);
    } else {
      statusDiv.innerHTML = "‚ùå " + result.error;
    }
  } catch(e) {
    statusDiv.innerHTML = "‚ùå " + e.message;
  }
});

// DELETE
function populateDeleteDropdown() {
  const select = document.getElementById("clientToDelete");
  select.innerHTML = "<option value=''>Select client...</option>";
  clients.forEach((c, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = c[0];
    select.appendChild(opt);
  });
}

document.getElementById("clientToDelete").addEventListener("change", (e) => {
  document.getElementById("confirmDeleteBtn").disabled = e.target.value === "";
});

document.getElementById("confirmDeleteBtn").addEventListener("click", async () => {
  const idx = parseInt(document.getElementById("clientToDelete").value);
  if(isNaN(idx)) return;
  
  const client = clients[idx];
  if(!confirm(`Delete "${client[0]}"?`)) return;
  
  const statusDiv = document.getElementById("deleteStatus");
  statusDiv.innerHTML = "‚è≥ Deleting...";
  statusDiv.style.display = "block";
  
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "deleteClient", data: { clientName: client[0] } })
    });
    
    const result = await response.json();
    if(result.success) {
      statusDiv.innerHTML = "‚úÖ Deleted!";
      setTimeout(() => location.reload(), 1500);
    } else {
      statusDiv.innerHTML = "‚ùå " + result.error;
    }
  } catch(e) {
    statusDiv.innerHTML = "‚ùå " + e.message;
  }
});

// TRASH
document.getElementById("trashBtn").addEventListener("click", async () => {
  const trashView = document.getElementById("trashView");
  trashView.style.display = trashView.style.display === "none" ? "block" : "none";
  
  if(trashView.style.display === "block") {
    const trashList = document.getElementById("trashList");
    trashList.innerHTML = "Loading...";
    
    try {
      const response = await fetch(APPS_SCRIPT_URL, {
        method: "POST",
        body: JSON.stringify({ action: "getTrash" })
      });
      
      const result = await response.json();
      
      if(result.success && result.trash && result.trash.length > 0) {
        trashList.innerHTML = result.trash.map((item, idx) => `
          <div style="padding:8px; border-bottom:1px solid #eee;">
            <b>${item[0]}</b><br><small>${item[1]} | ${item[2]}</small>
            <div style="margin-top:5px;">
              <button class="restoreBtn" data-idx="${idx}" style="padding:3px 6px; background:#27ae60; color:white; border:none; border-radius:2px; cursor:pointer; font-size:10px; margin-right:3px;">Restore</button>
              <button class="deletePermBtn" data-idx="${idx}" style="padding:3px 6px; background:#c0392b; color:white; border:none; border-radius:2px; cursor:pointer; font-size:10px;">Delete</button>
            </div>
          </div>
        `).join("");
        
        document.querySelectorAll(".restoreBtn").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            if(confirm("Restore?")) await restoreClient(parseInt(e.target.dataset.idx));
          });
        });
        
        document.querySelectorAll(".deletePermBtn").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            if(confirm("Permanently delete?")) await permanentlyDeleteClient(parseInt(e.target.dataset.idx));
          });
        });
      } else {
        trashList.innerHTML = "Empty";
      }
    } catch(e) {
      trashList.innerHTML = "Error: " + e.message;
    }
  }
});

async function restoreClient(idx) {
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "restoreClient", index: idx })
    });
    const result = await response.json();
    if(result.success) setTimeout(() => location.reload(), 1500);
  } catch(e) {}
}

async function permanentlyDeleteClient(idx) {
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({ action: "permanentlyDelete", index: idx })
    });
    const result = await response.json();
    if(result.success) setTimeout(() => location.reload(), 1500);
  } catch(e) {}
}

// BUTTON LISTENERS
document.getElementById("addClientBtn").addEventListener("click", () => {
  const form = document.getElementById("addClientForm");
  form.style.display = form.style.display === "none" ? "block" : "none";
});

document.getElementById("editClientBtn").addEventListener("click", () => {
  const form = document.getElementById("editClientForm");
  form.style.display = form.style.display === "none" ? "block" : "none";
  if(form.style.display === "block") populateEditDropdown();
});

// EDIT CLIENT DROPDOWN
function populateEditDropdown() {
  const select = document.getElementById("clientToEdit");
  select.innerHTML = "<option value=''>Select client to edit...</option>";
  clients.forEach((c, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = c[0];
    select.appendChild(opt);
  });
}

document.getElementById("clientToEdit").addEventListener("change", (e) => {
  const idx = parseInt(e.target.value);
  if(isNaN(idx)) {
    document.getElementById("editClientName").disabled = true;
    document.getElementById("editClientIndustry").disabled = true;
    document.getElementById("editClientLocation").disabled = true;
    document.getElementById("editClientServiceArea").disabled = true;
    document.getElementById("saveEditBtn").disabled = true;
    document.getElementById("previewEditAreaBtn").disabled = true;
    document.getElementById("addEditAreaBtn").disabled = true;
    return;
  }
  
  const client = clients[idx];
  document.getElementById("editClientName").value = client[0];
  document.getElementById("editClientIndustry").value = client[1];
  document.getElementById("editClientLocation").value = client[2];
  document.getElementById("editClientServiceArea").value = client[3] || "";
  
  document.getElementById("editClientName").disabled = false;
  document.getElementById("editClientIndustry").disabled = false;
  document.getElementById("editClientLocation").disabled = false;
  document.getElementById("editClientServiceArea").disabled = false;
  document.getElementById("saveEditBtn").disabled = false;
   document.getElementById("previewEditAreaBtn").disabled = false;
   document.getElementById("addEditAreaBtn").disabled = false;
});

// Preview/add service area on Edit Client form
const previewEditBtn = document.getElementById("previewEditAreaBtn");
const addEditBtn = document.getElementById("addEditAreaBtn");
if (previewEditBtn && addEditBtn) {
  previewEditBtn.addEventListener("click", async () => {
    if (previewEditBtn.disabled) return;
    const entry = document.getElementById("editClientServiceArea").value.trim();
    await previewServiceAreaEntry(entry, document.getElementById("previewEditStatus"), 'edit');
  });
  addEditBtn.addEventListener("click", () => {
    if (addEditBtn.disabled) return;
    const input = document.getElementById("editClientServiceArea");
    const statusEl = document.getElementById("previewEditStatus");
    const entry = (lastPreviewEntry.edit || input.value.trim());
    if (!entry) { setPreviewStatus(statusEl, 'Nothing to add'); return; }
    appendEntryToInput(input, entry);
    setPreviewStatus(statusEl, `Added ${entry} to Service Area`);
  });
}

// SAVE EDIT
document.getElementById("saveEditBtn").addEventListener("click", async () => {
  const idx = parseInt(document.getElementById("clientToEdit").value);
  if(isNaN(idx)) return;
  
  const originalClient = clients[idx];
  const newName = document.getElementById("editClientName").value.trim();
  const newIndustry = document.getElementById("editClientIndustry").value.trim();
  const newLocation = document.getElementById("editClientLocation").value.trim();
  const newServiceArea = document.getElementById("editClientServiceArea").value.trim();
  
  if(!newName || !newIndustry || !newLocation) {
    alert("Please fill in Name, Industry, and Location");
    return;
  }
  
  if(!confirm(`Update "${originalClient[0]}"?`)) return;
  
  const statusDiv = document.getElementById("editStatus");
  statusDiv.innerHTML = "‚è≥ Updating...";
  statusDiv.style.display = "block";
  
  if(!APPS_SCRIPT_URL) {
    statusDiv.innerHTML = "Apps Script not configured.";
    return;
  }
  
  try {
    const response = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      body: JSON.stringify({
        action: "editClient",
        data: {
          originalName: originalClient[0],
          name: newName,
          industry: newIndustry,
          location: newLocation,
          serviceArea: newServiceArea,
          lat: originalClient[4][0],
          lng: originalClient[4][1]
        }
      })
    });
    
    const result = await response.json();
    if(result.success) {
      statusDiv.innerHTML = "‚úÖ Updated! Refreshing...";
      setTimeout(() => location.reload(), 1500);
    } else {
      statusDiv.innerHTML = "‚ùå Error: " + result.error;
    }
  } catch(e) {
    statusDiv.innerHTML = "‚ùå Error: " + e.message;
  }
});

document.getElementById("deleteClientBtn").addEventListener("click", () => {
  const form = document.getElementById("deleteClientForm");
  form.style.display = form.style.display === "none" ? "block" : "none";
  if(form.style.display === "block") populateDeleteDropdown();
});

document.querySelectorAll(".closeForm").forEach(btn => {
  btn.addEventListener("click", (e) => {
    document.getElementById(e.target.dataset.form).style.display = "none";
  });
});

function buildLegend(){
  const box=document.getElementById("legendBox");
  box.innerHTML="<button id='resetLegend'>Reset All</button><b>Industry</b><br><br>";
  const set=new Set();
  clients.forEach(c=>c[1].split(",").forEach(i=>set.add(i.trim())));
  [...set].sort().forEach(ind=>{
    legendStatus[ind]=legendStatus[ind]||false;
    const div=document.createElement("div");
    div.className="legend-item";
    div.innerHTML=`<div class="legend-color" style="background:${colors[ind]||"#666"}"></div>${ind}`;
    div.style.textDecoration=legendStatus[ind]?'line-through':'none';
    div.onclick=()=>{
      legendStatus[ind]=!legendStatus[ind];
      div.style.textDecoration=legendStatus[ind]?'line-through':'none';
      applyFilters();
    };
    box.appendChild(div);
  });

  document.getElementById("resetLegend").onclick = () => {
    Object.keys(legendStatus).forEach(k=>legendStatus[k]=false);
    document.querySelectorAll(".legend-item").forEach(d=>d.style.textDecoration="none");
    applyFilters();
  }
}

// INIT
document.getElementById("searchBox").addEventListener("input",applyFilters);
document.getElementById("toggleChartType").addEventListener("click",()=>{
  currentChartType=currentChartType==="bar"?"pie":"bar";
  document.getElementById("toggleChartType").innerText=currentChartType==="bar"?"Switch to Pie Chart":"Switch to Bar Chart";
  updateChart(filteredClients);
});

});
</script>
</body>
</html>